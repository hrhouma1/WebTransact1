# ğŸ› ï¸ Structure du projet

```
card-app
â”œâ”€â”€ src
â”‚   â””â”€â”€ main
â”‚       â””â”€â”€ java
â”‚           â””â”€â”€ com
â”‚               â””â”€â”€ exemple
â”‚                   â””â”€â”€ demo
â”‚                       â”œâ”€â”€ controller
â”‚                       â”‚   â””â”€â”€ CardController.java
â”‚                       â”œâ”€â”€ model
â”‚                       â”‚   â”œâ”€â”€ Card.java
â”‚                       â”‚   â””â”€â”€ Customer.java
â”‚                       â””â”€â”€ repository
â”‚                           â””â”€â”€ CardRepository.java
â””â”€â”€ src/main/resources
    â””â”€â”€ application.properties
```



# âš™ï¸ ProblÃ¨me rencontrÃ©



# ğŸ›‘ **Erreur 500 lors de l'ajout d'une carte**

Lorsque nous essayons d'ajouter une carte en utilisant une requÃªte POST avec le JSON suivant :

```json
{
    "customerId": 1, 
    "cardNumber": "1234-5678-9012-3456",
    "cardType": "Visa",
    "totalLimit": 5000,
    "amountUsed": 1000,
    "availableAmount": 4000,
    "createDt": "2024-08-30"
}
```

Nous obtenons une **erreur 500**.

L'erreur se produit parce que la relation entre `Card` et `Customer` dans JPA utilise un objet `Customer`, alors que dans la requÃªte, nous ne passons que le `customerId` (qui est un entier). JPA s'attend Ã  un objet `Customer` complet.

---

# âœ… Solutions possibles

# Solution 1 : Passer un objet `Customer` dans la requÃªte JSON

Au lieu de passer uniquement `customerId`, nous pouvons passer un objet `Customer` avec l'ID du client. Voici comment le JSON doit Ãªtre structurÃ© :

```json
{
    "customer": {
        "customerId": 1
    }, 
    "cardNumber": "1234-5678-9012-3456",
    "cardType": "Visa",
    "totalLimit": 5000,
    "amountUsed": 1000,
    "availableAmount": 4000,
    "createDt": "2024-08-30"
}
```

Avec ce format, JPA peut mapper correctement l'objet `Customer` et la relation Many-to-One entre `Card` et `Customer`.

### Modifications Ã  faire dans le contrÃ´leur

Si vous suivez cette solution, le contrÃ´leur n'a besoin d'aucune modification particuliÃ¨re. Il va automatiquement mapper l'objet `Customer` Ã  partir du JSON.

---

# Solution 2 : Passer uniquement `customerId` et gÃ©rer manuellement la relation

Si vous souhaitez garder l'approche oÃ¹ vous passez seulement un `customerId`, vous devez modifier le contrÃ´leur pour qu'il recherche l'objet `Customer` dans la base de donnÃ©es avant de sauvegarder la carte.

#### 1. Modifiez le contrÃ´leur `CardController`

Voici comment vous pouvez modifier la mÃ©thode POST dans le contrÃ´leur `CardController` pour gÃ©rer cette situation :

```java
@PostMapping("/add")
public Card addCard(@RequestBody Map<String, Object> cardData) {
    // Extraire customerId du JSON
    int customerId = (int) cardData.get("customerId");
    
    // Rechercher l'objet Customer dans la base de donnÃ©es
    Customer customer = customerRepository.findById(customerId)
        .orElseThrow(() -> new RuntimeException("Customer not found"));
    
    // CrÃ©er et remplir l'objet Card
    Card card = new Card();
    card.setCustomer(customer);
    card.setCardNumber((String) cardData.get("cardNumber"));
    card.setCardType((String) cardData.get("cardType"));
    card.setTotalLimit((int) cardData.get("totalLimit"));
    card.setAmountUsed((int) cardData.get("amountUsed"));
    card.setAvailableAmount((int) cardData.get("availableAmount"));
    card.setCreateDt(LocalDate.parse((String) cardData.get("createDt")));

    // Sauvegarder la carte
    return cardRepository.save(card);
}
```

Dans cette solution, nous extrayons manuellement le `customerId` du JSON, nous rÃ©cupÃ©rons l'objet `Customer` depuis la base de donnÃ©es, puis nous crÃ©ons une carte en liant cet objet `Customer` Ã  la nouvelle carte.

#### 2. Exemple de requÃªte JSON

Avec cette approche, la requÃªte JSON reste la suivante :

```json
{
    "customerId": 1, 
    "cardNumber": "1234-5678-9012-3456",
    "cardType": "Visa",
    "totalLimit": 5000,
    "amountUsed": 1000,
    "availableAmount": 4000,
    "createDt": "2024-08-30"
}
```

Le `customerId` est extrait du JSON, et l'objet `Customer` est rÃ©cupÃ©rÃ© dans le contrÃ´leur avant de sauvegarder la carte.

---

## ğŸš€ Tester l'application

### Ajouter une carte

Pour ajouter une carte Ã  la base de donnÃ©es, envoyez une requÃªte POST Ã  l'endpoint suivant :

```
POST http://localhost:8080/cards/add
```

#### Exemple de corps de la requÃªte (Solution 1 : Objet `Customer` complet) :

```json
{
    "customer": {
        "customerId": 1
    }, 
    "cardNumber": "1234-5678-9012-3456",
    "cardType": "Visa",
    "totalLimit": 5000,
    "amountUsed": 1000,
    "availableAmount": 4000,
    "createDt": "2024-08-30"
}
```

#### Exemple de corps de la requÃªte (Solution 2 : seulement `customerId`) :

```json
{
    "customerId": 1, 
    "cardNumber": "1234-5678-9012-3456",
    "cardType": "Visa",
    "totalLimit": 5000,
    "amountUsed": 1000,
    "availableAmount": 4000,
    "createDt": "2024-08-30"
}
```

### RÃ©cupÃ©rer toutes les cartes

Pour rÃ©cupÃ©rer toutes les cartes, envoyez une requÃªte GET Ã  l'endpoint suivant :

```
GET http://localhost:8080/cards/all
```

---



# 3Ã¨me Solution : Utiliser `mappedBy`

- La **troisiÃ¨me solution** consiste Ã  utiliser l'attribut `mappedBy` dans une relation bidirectionnelle entre les entitÃ©s `Customer` et `Card`. 
- Cela permet de dÃ©finir la relation de maniÃ¨re plus explicite, avec une gestion plus simple des opÃ©rations sur les deux entitÃ©s. Cette approche est particuliÃ¨rement utile lorsque vous voulez gÃ©rer la relation des deux cÃ´tÃ©s (de `Customer` vers `Card` et inversement).
- Dans cette solution, nous allons faire en sorte que l'entitÃ© `Customer` soit consciente des `Card` qui lui sont associÃ©es, en ajoutant une relation `OneToMany` Ã  l'entitÃ© `Customer`. De l'autre cÃ´tÃ©, l'entitÃ© `Card` conserve la relation `ManyToOne`, mais le lien est maintenant dÃ©fini dans `Customer`.

### Ã‰tapes pour mettre en place la solution avec `mappedBy`

#### 1. Modifiez la classe `Customer`

Ajoutez une collection de `Card` dans la classe `Customer` pour reprÃ©senter la relation bidirectionnelle. Utilisez l'annotation `@OneToMany` avec l'attribut `mappedBy` pour indiquer que cette relation est gÃ©rÃ©e du cÃ´tÃ© de l'entitÃ© `Card`.

```java
package com.exemple.demo.model;

import jakarta.persistence.*;
import java.util.List;

@Entity
@Table(name = "customer")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "customer_id")
    private int customerId;

    @Column(name = "customer_last_name")
    private String customerLastName;

    @Column(name = "customer_first_name")
    private String customerFirstName;

    // Ajoutez une liste de cartes
    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL)
    private List<Card> cards;

    // Constructeurs
    public Customer() {
    }

    public Customer(String customerLastName, String customerFirstName) {
        this.customerLastName = customerLastName;
        this.customerFirstName = customerFirstName;
    }

    // Getters et Setters
    public int getCustomerId() {
        return customerId;
    }

    public void setCustomerId(int customerId) {
        this.customerId = customerId;
    }

    public String getCustomerLastName() {
        return customerLastName;
    }

    public void setCustomerLastName(String customerLastName) {
        this.customerLastName = customerLastName;
    }

    public String getCustomerFirstName() {
        return customerFirstName;
    }

    public void setCustomerFirstName(String customerFirstName) {
        this.customerFirstName = customerFirstName;
    }

    public List<Card> getCards() {
        return cards;
    }

    public void setCards(List<Card> cards) {
        this.cards = cards;
    }
}
```

#### Explication :

- **`@OneToMany(mappedBy = "customer")`** : Indique que la relation est gÃ©rÃ©e du cÃ´tÃ© de `Card`. L'attribut `mappedBy` fait rÃ©fÃ©rence Ã  l'attribut `customer` dans la classe `Card`.
- **`cascade = CascadeType.ALL`** : Permet de propager les opÃ©rations (comme `persist`, `remove`, etc.) de l'entitÃ© `Customer` vers ses cartes.

#### 2. Conservez la classe `Card` telle quelle

Vous n'avez pas besoin de modifier la classe `Card` si vous avez dÃ©jÃ  une relation `ManyToOne` correctement dÃ©finie.

```java
package com.exemple.demo.model;

import jakarta.persistence.*;
import java.time.LocalDate;

@Entity
@Table(name = "card")
public class Card {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "card_id")
    private int cardId;

    @ManyToOne
    @JoinColumn(name = "customer_id", nullable = false)
    private Customer customer;

    @Column(name = "card_number")
    private String cardNumber;

    @Column(name = "card_type")
    private String cardType;

    @Column(name = "total_limit")
    private int totalLimit;

    @Column(name = "amount_used")
    private int amountUsed;

    @Column(name = "available_amount")
    private int availableAmount;

    @Column(name = "create_dt")
    private LocalDate createDt;

    // Constructeurs, Getters et Setters...
}
```

#### 3. RequÃªte JSON

Vous pouvez maintenant utiliser la mÃªme requÃªte JSON qu'auparavant :

```json
{
    "customer": {
        "customerId": 1
    }, 
    "cardNumber": "1234-5678-9012-3456",
    "cardType": "Visa",
    "totalLimit": 5000,
    "amountUsed": 1000,
    "availableAmount": 4000,
    "createDt": "2024-08-30"
}
```

La relation sera automatiquement gÃ©rÃ©e par JPA grÃ¢ce Ã  `mappedBy` dans la classe `Customer`. JPA s'assurera que lorsque vous ajoutez une carte Ã  un client, la base de donnÃ©es reliera correctement les deux entitÃ©s.

#### 4. Avantages de cette approche

- **Gestion automatique** : Avec `mappedBy`, vous obtenez une relation bidirectionnelle entre `Customer` et `Card`. Cela facilite la gestion des opÃ©rations qui concernent les deux entitÃ©s.
- **Cascading** : Vous pouvez facilement persister ou supprimer des entitÃ©s associÃ©es en une seule opÃ©ration.

#### 5. Tester l'application

1. **Ajout de cartes** :
   - Envoyez une requÃªte POST Ã  l'endpoint suivant pour ajouter une carte associÃ©e Ã  un client :
   
   ```
   POST http://localhost:8080/cards/add
   ```
   
2. **RÃ©cupÃ©ration des clients et cartes** :
   - Vous pouvez maintenant rÃ©cupÃ©rer un client et voir les cartes associÃ©es grÃ¢ce Ã  la relation bidirectionnelle.

---

## Conclusion

Avec l'option `mappedBy`, vous avez maintenant une gestion complÃ¨te des relations bidirectionnelles entre les entitÃ©s `Customer` et `Card`. Cela offre plus de flexibilitÃ© et facilite la gestion des opÃ©rations sur ces entitÃ©s. Si vous souhaitez une gestion plus propre et automatisÃ©e des relations, cette approche est la plus recommandÃ©e.

---

## Alternatives de gestion des relations

1. **Passer un objet `Customer` complet dans la requÃªte JSON**.
2. **GÃ©rer manuellement le `customerId` dans le contrÃ´leur**.
3. **Utiliser `mappedBy` pour une relation bidirectionnelle**.

Chaque solution a ses avantages, mais la troisiÃ¨me solution avec `mappedBy` est idÃ©ale si vous souhaitez maintenir une relation propre et facilement gÃ©rable entre vos entitÃ©s.




------------

# ğŸ‰ğŸ‰ **FÃ©licitations** ğŸ‰ğŸ‰

Vous avez obtenu **28%** du lab ğŸ’¯ ! Câ€™est **garanti** si vous Ãªtes arrivÃ©(e) jusque-lÃ  ! ğŸ˜ Maintenant, on va chercher ensemble les **78% restants**. ğŸ“ˆ

â¡ï¸ **Pas question de tester votre vigilance maintenant, mais sachez que vous Ãªtes le/la Boss !** ğŸ‘‘ Vous Ãªtes les maÃ®tres de Spring Boot âš™ï¸, et je suis **super fier** de vous ! ğŸ’ªğŸ‰

â¡ï¸â¡ï¸ **Continuez et progressez !** ğŸ” Vous Ãªtes Ã  un pas de devenir des **experts** dans ce domaine ! ğŸŒŸ

â¡ï¸â¡ï¸â¡ï¸ **Rendez-vous ici pour la suite !** ğŸ“… ğŸ

â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸â¡ï¸   [**4.3.Cahier-de-charge-partie-1**](4.3.Cahier-de-charge-partie-1.md) 







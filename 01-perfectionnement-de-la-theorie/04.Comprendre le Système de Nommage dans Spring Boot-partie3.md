
-------------------------
# Comprendre le Système de Nommage dans Spring Boot-partie3 - *JOINTURES*
-------------------------

Lorsque vous effectuez une jointure dans Spring Data JPA, vous ne mentionnez pas directement l'entité dans laquelle vous vous trouvez (c'est implicite), mais vous utilisez la relation (le nom de l'attribut qui fait référence à l'autre entité) pour traverser la relation.

#### Diagramme des entités : `Employee` et `Department`

Nous allons utiliser deux entités pour illustrer les jointures.

```
+-----------------------------+             +-----------------------------+
|          Employee            |             |        Department           |
+-----------------------------+             +-----------------------------+
| - employeeId (PK)            |             | - departmentId (PK)          |
| - firstName                  |             | - departmentName             |
| - lastName                   |             | - location                   |
| - salary                     |             |                             |
| - departmentId (FK)          |             |                             |
+-----------------------------+             +-----------------------------+
```

Dans cette structure, un employé (*Employee*) est lié à un département (*Department*) via une clé étrangère `departmentId`. Un employé appartient à un seul département, et un département peut avoir plusieurs employés.

### Comment réaliser une jointure avec Spring Data JPA ?

Pour effectuer une jointure entre deux entités dans Spring Data JPA, vous devez comprendre le modèle de relation. Supposons que l'entité `Employee` ait une relation avec `Department` via l'attribut `departmentId`. Vous utiliserez cet attribut pour effectuer la jointure.

#### Exemple de jointure :

- **Nom de la méthode** : `findByDepartmentDepartmentName`
- **Explication** :
  - `findBy` : Indique qu'il s'agit d'une requête de recherche.
  - `Department` : Nom de la relation dans l'entité `Employee` qui fait référence à l'entité `Department`. Il correspond au champ `department` dans `Employee` qui est de type `Department`.
  - `DepartmentName` : Nom de l'attribut dans l'entité `Department` que vous voulez interroger.

La syntaxe pour une jointure est toujours :  
```java
findBy[NomRelation][AttributDansRelation][Opérateur]...
```

**Note importante** : Le nom de la table `Employee` n'est pas mentionné dans la méthode car vous êtes déjà dans le contexte de cette entité (c'est implicite). Vous mentionnez uniquement la relation (`Department`) et l'attribut dans l'autre table (par exemple, `DepartmentName`).

---

### Structure des méthodes pour les jointures :

#### Jointure simple :

```java
findByDepartmentDepartmentName(String departmentName);
```
Cette méthode effectue une jointure entre `Employee` et `Department` et filtre les employés en fonction du nom du département.

#### Jointure avec des conditions supplémentaires :

```java
findBySalaryGreaterThanAndDepartmentDepartmentName(Double salary, String departmentName);
```
Ici, nous combinons une jointure entre `Employee` et `Department` avec une condition sur le salaire de l'employé et le nom du département.

---

### Tableau des requêtes et des méthodes JPA avec jointures

| **Niveau**   | **Requête SQL**                                                                                                                                  | **Indice**                                                          | **Nom de la méthode JPA**              |
|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|-----------------------------------------|
| **Facile**   | `SELECT e.*, d.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId;`                                                            | Récupérer tous les employés avec leurs départements.                  | `findAll()`                             |
| **Facile**   | `SELECT e.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE d.departmentName = 'HR';`                                    | Récupérer les employés du département 'HR'.                           | `findByDepartmentDepartmentName(String departmentName)` |
| **Moyen**    | `SELECT e.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE e.salary > 50000 AND d.departmentName = 'IT';`               | Récupérer les employés avec un salaire > 50000 dans 'IT'.             | `findBySalaryGreaterThanAndDepartmentDepartmentName(Double salary, String departmentName)` |
| **Moyen**    | `SELECT e.*, d.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE e.salary > 40000;`                                      | Récupérer les employés avec un salaire > 40000.                       | `findBySalaryGreaterThan(Double salary)` |
| **Moyen**    | `SELECT e.*, d.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE d.departmentName = 'Finance' ORDER BY e.salary DESC;`   | Récupérer les employés de 'Finance' triés par salaire décroissant.    | `findByDepartmentDepartmentNameOrderBySalaryDesc(String departmentName)` |
| **Difficile**| `SELECT e.*, d.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE e.salary > 60000 AND d.departmentName = 'Marketing';`   | Récupérer les employés dans 'Marketing' avec un salaire > 60000.      | `findBySalaryGreaterThanAndDepartmentDepartmentName(Double salary, String departmentName)` |
| **Difficile**| `SELECT COUNT(e.employeeId) FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE d.departmentName = 'HR';`                   | Compter les employés dans le département 'HR'.                        | `countByDepartmentDepartmentName(String departmentName)` |
| **Difficile**| `SELECT SUM(e.salary) FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE d.departmentName = 'IT';`                         | Calculer la somme des salaires dans 'IT'.                             | `sumSalaryByDepartmentDepartmentName(String departmentName)` |
| **Difficile**| `SELECT e.*, d.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE d.departmentName = 'HR' AND e.salary BETWEEN 40000 AND 60000;` | Récupérer les employés dans 'HR' avec un salaire compris entre 40000 et 60000. | `findBySalaryBetweenAndDepartmentDepartmentName(Double min, Double max, String departmentName)` |

---

### Explications supplémentaires

1. **Jointure simple** :
   - La méthode `findByDepartmentDepartmentName` réalise une jointure entre `Employee` et `Department` pour rechercher des employés en fonction du nom du département.

2. **Combinaison de jointures et de conditions** :
   - `findBySalaryGreaterThanAndDepartmentDepartmentName` combine une condition de salaire et une jointure sur le nom du département.

3. **Agrégations et comptage** :
   - Les méthodes comme `countByDepartmentDepartmentName` permettent de compter les employés dans un département, et `sumSalaryByDepartmentDepartmentName` calcule la somme des salaires dans un département.

---

### Recommandations pour les jointures avancées :
- **Utilisation des annotations JPQL** : Pour des requêtes encore plus complexes, vous pouvez utiliser l'annotation `@Query` et écrire directement du JPQL ou SQL natif.
- **Optimisation** : Si vos jointures sont trop complexes, envisagez d'utiliser des vues ou de simplifier vos relations de données.

Grâce à ces conventions de nommage, vous pouvez éviter d'écrire manuellement des requêtes SQL tout en effectuant des jointures sophistiquées et en gardant un code lisible et maintenable.















----
# JPA
----

**üíÄ Important ! Lecture Obligatoire üíÄ**

üîç Avant de commencer l'exercice dans **3.3**, il est crucial que vous lisiez **3.1 Cours Persistance JPA Th√©orie.md**. Ce document est exhaustif et couvre tous les concepts importants qui seront discut√©s en classe. Cependant, si vous pr√©f√©rez un r√©sum√© rapide, passez directement au **3.2 R√©sum√© Persistance JPA Th√©orie.md**

üëâ [‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è SECTION SUIVANTE - Allez au R√âSUM√â](3.2.Resume-Persistance-JPA-Theorie.md)

üëâ [‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è EXERCICE 2 ](3.3.Application-Pratique2-Exercice2.md) 

----
# Table des mati√®res
----


1. <a href="#introduction-a-jpa">Introduction √† JPA</a>
2. <a href="#installation-et-configuration">Installation et Configuration</a>
   - <a href="#installation-des-dependances">Installation des D√©pendances</a>
   - <a href="#configuration-de-la-base-de-donnees">Configuration de la Base de Donn√©es</a>
   - <a href="#exigences-techniques">Exigences Techniques</a>
3. <a href="#entites-jpa">Entit√©s JPA</a>
   - <a href="#creation-des-entites">Cr√©ation des Entit√©s</a>
   - <a href="#annotations-principales">Annotations Principales</a>
4. <a href="#relations-entre-entites">Relations Entre Entit√©s</a>
   - <a href="#relation-one-to-one">Relation One-to-One</a>
   - <a href="#relation-one-to-many">Relation One-to-Many</a>
   - <a href="#relation-many-to-many">Relation Many-to-Many</a>
5. <a href="#gestion-des-transactions">Gestion des Transactions</a>
   - <a href="#introduction-aux-transactions">Introduction aux Transactions</a>
   - <a href="#propagation-et-isolation-des-transactions">Propagation et Isolation des Transactions</a>
6. <a href="#requetes-et-interactions-avec-la-base-de-donnees">Requ√™tes et Interactions avec la Base de Donn√©es</a>
   - <a href="#jpql-java-persistence-query-language">JPQL (Java Persistence Query Language)</a>
   - <a href="#criteria-api">Criteria API</a>
   - <a href="#requetes-native-sql">Requ√™tes Native SQL</a>
7. <a href="#optimisation-des-performances">Optimisation des Performances</a>
   - <a href="#lazy-vs-eager-loading">Lazy vs Eager Loading</a>
   - <a href="#caching-avec-jpa">Caching avec JPA</a>
8. <a href="#validation-des-donnees">Validation des Donn√©es</a>
   - <a href="#utilisation-de-bean-validation">Utilisation de Bean Validation</a>
9. <a href="#gestion-des-historiques-avec-hibernate-envers">Gestion des Historiques avec Hibernate Envers</a>
   - <a href="#introduction-a-hibernate-envers">Introduction √† Hibernate Envers</a>
   - <a href="#configuration-de-hibernate-envers">Configuration de Hibernate Envers</a>
   - <a href="#exemples-dutilisation">Exemples d'Utilisation</a>
10. <a href="#conclusion-et-ressources-complementaires">Conclusion et Ressources Compl√©mentaires</a>
11. <a href="#table-des-matieres">Retour en Haut</a>

---
---
---

# <a name="introduction-a-jpa"></a> 1. Introduction √† JPA

# 1.1. Contenu de la section
- Dans cette section, nous explorerons les bases de JPA (Java Persistence API), ses objectifs, ses avantages, et son r√¥le au sein de l'architecture Java EE. 
- Nous aborderons √©galement le concept de persistance des objets dans une base de donn√©es relationnelle.

# 1.2. Pr√©sentation de JPA
- JPA est une sp√©cification Java qui simplifie la gestion des donn√©es relationnelles dans les applications Java.
- En permettant de mapper des objets Java √† des tables de bases de donn√©es relationnelles, JPA r√©duit la complexit√© du code SQL n√©cessaire pour les op√©rations CRUD (Create, Read, Update, Delete).

[‚¨ÜÔ∏è Retour en Haut](#jpa)

---
---
---

# <a name="installation-et-configuration"></a> 2. Installation et Configuration

# <a name="installation-des-dependances"></a> 2.1. Installation des D√©pendances

Pour commencer avec JPA, ajoutez les d√©pendances n√©cessaires dans le fichier `pom.xml` :

```xml
<dependencies>
    <!-- D√©pendance pour JPA avec Jakarta -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <!-- D√©pendance pour PostgreSQL -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.3.1</version>
    </dependency>
</dependencies>
```

[‚¨ÜÔ∏è Retour en Haut](#jpa)

# <a name="configuration-de-la-base-de-donnees"></a> 2.2. Configuration de la Base de Donn√©es
Configurez le fichier `application.properties` pour connecter JPA √† une base de donn√©es, comme PostgreSQL.

# <a name="exigences-techniques"></a> 2.3. Exigences Techniques

Pour garantir le bon fonctionnement de JPA dans votre projet, il est essentiel de respecter certaines exigences techniques.

| **Exigence**            | **Description**                                                                 |
|-------------------------|---------------------------------------------------------------------------------|
| **Annotations**         | Utilisation d'annotations telles que `@Entity`, `@Table`, `@Id`, `@Column`.     |
| **Constructeur par d√©faut** | Chaque entit√© doit avoir un constructeur sans param√®tres.                    |
| **Getters et Setters**  | Fournir des m√©thodes getter et setter pour chaque attribut persistant.           |
| **Configuration POM**   | Ajouter les d√©pendances n√©cessaires dans le fichier `pom.xml`.                  |

[‚¨ÜÔ∏è Retour en Haut](#jpa)

---
---
---

# <a name="entites-jpa"></a> 3. Entit√©s JPA

Les entit√©s JPA repr√©sentent les objets du domaine de votre application qui sont persist√©s dans une base de donn√©es relationnelle. Une entit√© est une classe Java ordinaire (POJO - Plain Old Java Object) qui est mapp√©e √† une table de la base de donn√©es, et chaque instance de cette classe correspond √† une ligne de la table.

# <a name="creation-des-entites"></a> 3.1. Cr√©ation des Entit√©s

La cr√©ation d'entit√©s est une √©tape fondamentale dans l'utilisation de JPA. Une entit√© JPA est d√©finie comme une classe Java annot√©e avec `@Entity`. Cette annotation signale √† JPA que la classe est une entit√© qui doit √™tre persist√©e dans une base de donn√©es. En outre, chaque entit√© doit avoir une cl√© primaire, souvent annot√©e avec `@Id`.

# √âtapes de cr√©ation d'une entit√© JPA

3.1.1. **D√©finir la classe Java** :
   Commencez par cr√©er une classe Java qui repr√©sentera l'entit√©. Cette classe doit √™tre publique et poss√©der un constructeur par d√©faut sans arguments.

3.1.2. **Annoter la classe avec `@Entity`** :
   Ajoutez l'annotation `@Entity` pour indiquer que la classe est une entit√© JPA.

3.1.3. **D√©finir la cl√© primaire** :
   Utilisez l'annotation `@Id` pour sp√©cifier le champ qui servira de cl√© primaire. Il est √©galement courant d'utiliser `@GeneratedValue` pour indiquer que la valeur de la cl√© primaire sera g√©n√©r√©e automatiquement.

3.1.4. **Mapper les champs aux colonnes** :
   Chaque champ de la classe peut √™tre mapp√© √† une colonne de la base de donn√©es en utilisant l'annotation `@Column`. Si le nom du champ est identique √† celui de la colonne, l'annotation `@Column` peut √™tre omise.

3.1.5. **Ajouter les getters et setters** :
   Pour permettre √† JPA d'acc√©der et de manipuler les champs de l'entit√©, il est important de fournir des m√©thodes getter et setter pour chaque champ.

---

# Exemple complet d'une entit√© JPA avec Jakarta Persistence

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Column;

@Entity
@Table(name = "customer")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "customer_id")
    private int customerId;

    @Column(name = "customer_last_name")
    private String lastName;

    @Column(name = "customer_first_name")
    private String firstName;

    @Column(name = "email")
    private String email;

    // Constructeur par d√©faut
    public Customer() {}

    // Constructeur avec param√®tres
    public Customer(String lastName, String firstName, String email) {
        this.lastName = lastName;
        this.firstName = firstName;
        this.email = email;
    }

    // Getters et Setters
    public int getCustomerId() {
        return customerId;
    }

    public void setCustomerId(int customerId) {
        this.customerId = customerId;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
```

### Travailler avec la nouvelle version de JPA :  Jakarta Persistence

Cet exemple utilise les importations du package `jakarta.persistence`, qui fait partie de Jakarta EE, l'√©volution de Java EE apr√®s son transfert √† la Fondation Eclipse. Jakarta EE repr√©sente l'avenir du d√©veloppement Java entreprise, et il est recommand√© d'utiliser `jakarta.persistence` pour les nouveaux projets afin de rester compatible avec les versions futures.

### Travail avec l'ancienne version de JPA : `javax.persistence`

Si vous travaillez avec une version ant√©rieure de JPA ou dans un environnement Java EE (avant le transfert √† Jakarta EE), vous pourriez utiliser `javax.persistence`. Voici comment le m√™me exemple d'entit√© appara√Ætrait avec `javax.persistence` :

```java
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Column;

@Entity
@Table(name = "customer")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "customer_id")
    private int customerId;

    @Column(name = "customer_last_name")
    private String lastName;

    @Column(name = "customer_first_name")
    private String firstName;

    @Column(name = "email")
    private String email;

    // Constructeur par d√©faut
    public Customer() {}

    // Constructeur avec param√®tres
    public Customer(String lastName, String firstName, String email) {
        this.lastName = lastName;
        this.firstName = firstName;
        this.email = email;
    }

    // Getters et Setters
    public int getCustomerId() {
        return customerId;
    }

    public void setCustomerId(int customerId) {
        this.customerId = customerId;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
```

### Quand utiliser `javax.persistence` ?

- **Projets existants** : Si vous travaillez sur un projet qui utilise Java EE et `javax.persistence`, il est logique de continuer √† utiliser cette version pour √©viter des modifications majeures du code.
- **Compatibilit√©** : Si vous devez assurer la compatibilit√© avec des serveurs d'applications ou des environnements qui ne supportent pas encore Jakarta EE, vous utiliserez `javax.persistence`.

# Pour conclure !

Pour les nouveaux projets, il est recommand√© de commencer avec `jakarta.persistence` afin de tirer parti des am√©liorations futures et de garantir la compatibilit√© √† long terme avec Jakarta EE. Cependant, pour des raisons de compatibilit√© ou lors de la maintenance de projets existants, `javax.persistence` reste une option valide.



# <a name="creation-des-entites"></a> 3.2. Les annotations JPA en d√©tails


Les annotations JPA sont essentielles pour configurer le mapping entre les classes Java et les tables de base de donn√©es, ainsi que pour d√©finir les comportements sp√©cifiques li√©s √† la persistance des objets. Voici une br√®ve introduction aux annotations JPA que nous allons explorer en d√©tail plus bas dans le point 3.2:

- **`@Entity`** : Indique que la classe `Customer` est une entit√© JPA.
- **`@Table(name = "customer")`** : Sp√©cifie que cette entit√© est mapp√©e √† la table `customer` dans la base de donn√©es.
- **`@Id`** : Indique que le champ `customerId` est la cl√© primaire de l'entit√©.
- **`@GeneratedValue(strategy = GenerationType.IDENTITY)`** : Sp√©cifie que la valeur de `customerId` est g√©n√©r√©e automatiquement par la base de donn√©es (g√©n√©ralement pour les colonnes auto-incr√©ment√©es).
- **`@Column(name = "customer_last_name")`** : Associe le champ `lastName` √† la colonne `customer_last_name` de la table.

[‚¨áÔ∏è Voir les annotations en d√©tail](#annotations-principales)

### <a name="annotations-principales"></a> 3.2. Annotations Principales

Les annotations JPA sont utilis√©es pour configurer le mapping entre les classes Java et les tables de base de donn√©es, ainsi que pour d√©finir des comportements sp√©cifiques li√©s √† la persistance.

#### Principales annotations JPA et leur usage

1. **`@Entity`** :
   - Utilis√©e pour marquer une classe comme une entit√© persistante.
   - Chaque classe annot√©e avec `@Entity` est mapp√©e √† une table dans la base de donn√©es.

2. **`@Table`** :
   - Permet de sp√©cifier le nom de la table de la base de donn√©es √† laquelle l'entit√© est mapp√©e.
   - Syntaxe : `@Table(name = "nom_de_la_table")`.
   - Utile lorsque le nom de la classe et celui de la table sont diff√©rents.

3. **`@Id`** :
   - Indique le champ qui sert de cl√© primaire pour l'entit√©.
   - Chaque entit√© doit avoir un champ annot√© avec `@Id`.

4. **`@GeneratedValue`** :
   - Sp√©cifie la strat√©gie de g√©n√©ration de la valeur pour le champ cl√© primaire.
   - Strat√©gies communes : `IDENTITY`, `SEQUENCE`, `AUTO`, `TABLE`.
   - Exemple : `@GeneratedValue(strategy = GenerationType.IDENTITY)`.

5. **`@Column`** :
   - Associe un champ de l'entit√© √† une colonne de la table de la base de donn√©es.
   - Permet de sp√©cifier des propri√©t√©s de la colonne comme `nullable`, `length`, `unique`.
   - Syntaxe : `@Column(name = "nom_de_la_colonne", nullable = false, length = 50)`.

6. **`@Temporal`** :
   - Utilis√©e pour sp√©cifier le type temporel d‚Äôun champ de date (`Date` ou `Calendar`).
   - Types : `DATE`, `TIME`, `TIMESTAMP`.
   - Exemple : `@Temporal(TemporalType.DATE)` pour une date sans heure.

7. **`@Transient`** :
   - Indique qu'un champ ne doit pas √™tre persist√© dans la base de donn√©es.
   - Utile pour les champs calcul√©s ou temporaires.
   - Exemple : `@Transient private int age;`.

8. **`@Lob`** :
   - Indique que le champ stocke un grand objet binaire (BLOB) ou un grand objet texte (CLOB).
   - Utilis√© pour les champs qui n√©cessitent un stockage en dehors des types standards.
   - Exemple : `@Lob private byte[] photo;`.

9. **`@Enumerated`** :
   - Utilis√©e pour mapper un type √©num√©r√© Java (`enum`) √† une colonne de la base de donn√©es.
   - Modes : `ORDINAL` (stocke l'index) et `STRING` (stocke le nom).
   - Exemple : `@Enumerated(EnumType.STRING)`.

#### Exemple d'utilisation combin√©e des annotations

```java
@Entity
@Table(name = "employee")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "emp_seq")
    @SequenceGenerator(name = "emp_seq", sequenceName = "employee_seq", allocationSize = 1)
    private Long id;

    @Column(name = "first_name", nullable = false, length = 50)
    private String firstName;

    @Column(name = "last_name", nullable = false, length = 50)
    private String lastName;

    @Column(name = "date_of_birth")
    @Temporal(TemporalType.DATE)
    private Date dateOfBirth;

    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type")
    private EmploymentType employmentType;

    @Lob
    @Column(name = "profile_picture")
    private byte[] profilePicture;

    @Transient
    private int age;

    // Getters et Setters
}
```

#### Explications d√©taill√©es

- **`@SequenceGenerator`** : D√©clare un g√©n√©rateur de s√©quence pour la cl√© primaire.
- **`@Temporal(TemporalType.DATE)`** : Indique que `dateOfBirth` est une date sans heure.
- **`@Enumerated(EnumType.STRING)`** : Stocke la valeur de l'√©num√©ration `EmploymentType` en tant que cha√Æne de caract√®res.
- **`@Lob`** : Sp√©cifie que `profilePicture` est un grand objet binaire (BLOB).
- **`@Transient`** : Le champ `age` ne sera pas persist√© dans la base de donn√©es.











[‚¨ÜÔ∏è Retour en Haut](#jpa)

---

## <a name="relations-entre-entites"></a> 4. Relations Entre Entit√©s

Les relations entre entit√©s sont essentielles pour mod√©liser les associations entre objets dans un syst√®me. Voici comment vous pouvez repr√©senter ces relations en JPA, avec des exemples concrets et des diagrammes en ASCII pour une meilleure compr√©hension.

### <a name="relation-one-to-one"></a> 4.1. Relation One-to-One

#### Introduction

Une relation `One-to-One` signifie qu'une entit√© est li√©e √† une autre entit√©, et vice versa. Dans notre exemple, supposons que chaque client (`Customer`) a le droit d'avoir un et uniquement un seul compte bancaire (`Account`) (ce qui n'est pas n√©cessairement vrai, mais nous supposons que c'Est vrai pour cet exemple), et chaque compte bancaire appartient √† un seul client.

#### Diagramme 

```
Customer ‚îÄ‚îÄ‚îÄ‚îÄ1:1‚îÄ‚îÄ‚îÄ‚îÄ Account
  ID                    ID
  Name                  AccountNumber
```

#### Exemple pratique

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.OneToOne;
import jakarta.persistence.JoinColumn;

@Entity
@Table(name = "customer")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToOne
    @JoinColumn(name = "account_id")
    private Account account;

    // Getters et Setters
}

@Entity
@Table(name = "account")
public class Account {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String accountNumber;

    @OneToOne(mappedBy = "account")
    private Customer customer;

    // Getters et Setters
}
```

#### Explications

- **`@OneToOne`** : D√©finit une relation `One-to-One` entre `Customer` et `Account`.
- **`@JoinColumn(name = "account_id")`** : Sp√©cifie que la colonne `account_id` dans la table `customer` contient la cl√© √©trang√®re vers `Account`.

---

### <a name="relation-one-to-many"></a> 4.2. Relation One-to-Many

#### Introduction

Une relation `One-to-Many` signifie qu'une entit√© peut √™tre associ√©e √† plusieurs autres entit√©s. Dans cet exemple, un client (`Customer`) peut poss√©der plusieurs cartes de cr√©dit (`Card`), mais chaque carte appartient √† un seul client.

#### Diagramme 

```
Customer ‚îÄ‚îÄ‚îÄ‚îÄ1:N‚îÄ‚îÄ‚îÄ‚îÄ Card
  ID                    ID
  Name                  CardNumber
```

#### Exemple pratique

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.OneToMany;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.JoinColumn;
import java.util.List;

@Entity
@Table(name = "customer")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "customer")
    private List<Card> cards;

    // Getters et Setters
}

@Entity
@Table(name = "card")
public class Card {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String cardNumber;

    @ManyToOne
    @JoinColumn(name = "customer_id")
    private Customer customer;

    // Getters et Setters
}
```

#### Explications

- **`@OneToMany(mappedBy = "customer")`** : Indique que `Customer` peut avoir plusieurs `Card` et que `Card` est responsable de la relation.
- **`@ManyToOne`** : Indique que chaque `Card` appartient √† un seul `Customer`.
- **`@JoinColumn(name = "customer_id")`** : Sp√©cifie la cl√© √©trang√®re `customer_id` dans la table `card`.

---

### <a name="relation-many-to-many"></a> 4.3. Relation Many-to-Many

#### Introduction

Une relation `Many-to-Many` signifie que plusieurs entit√©s peuvent √™tre li√©es √† plusieurs autres entit√©s. Par exemple, un client peut avoir plusieurs cartes de fid√©lit√© (`LoyaltyCard`), et chaque carte de fid√©lit√© peut √™tre partag√©e entre plusieurs clients.

#### Diagramme 

```
Customer ‚îÄ‚îÄ‚îÄ‚îÄN:M‚îÄ‚îÄ‚îÄ‚îÄ LoyaltyCard
  ID                    ID
  Name                  CardNumber
```

#### Exemple pratique

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.JoinTable;
import jakarta.persistence.JoinColumn;
import java.util.Set;

@Entity
@Table(name = "customer")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany
    @JoinTable(
        name = "customer_loyalty_card",
        joinColumns = @JoinColumn(name = "customer_id"),
        inverseJoinColumns = @JoinColumn(name = "loyalty_card_id")
    )
    private Set<LoyaltyCard> loyaltyCards;

    // Getters et Setters
}

@Entity
@Table(name = "loyalty_card")
public class LoyaltyCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String cardNumber;

    @ManyToMany(mappedBy = "loyaltyCards")
    private Set<Customer> customers;

    // Getters et Setters
}
```

#### Explications

- **`@ManyToMany`** : D√©finit une relation `Many-to-Many` entre `Customer` et `LoyaltyCard`.
- **`@JoinTable`** : Sp√©cifie la table de jointure `customer_loyalty_card` pour g√©rer l'association.
- **`joinColumns` et `inverseJoinColumns`** : D√©finissent les colonnes de jointure respectivement pour `Customer` et `LoyaltyCard`.



[‚¨ÜÔ∏è Retour en Haut](#jpa)

---
---
---
---

## <a name="gestion-des-transactions"></a> 5. Gestion des Transactions

La gestion des transactions est un concept fondamental dans le d√©veloppement d'applications Java qui interagissent avec des bases de donn√©es. Elle garantit que les op√©rations sur les donn√©es sont ex√©cut√©es de mani√®re coh√©rente et fiable, m√™me en cas de d√©faillance. En JPA, les transactions sont utilis√©es pour regrouper une s√©rie d'op√©rations de base de donn√©es qui doivent √™tre ex√©cut√©es comme une unit√© atomique, ce qui signifie qu'elles r√©ussissent ou √©chouent ensemble.

### <a name="introduction-aux-transactions"></a> 5.1. Introduction aux Transactions

#### Qu'est-ce qu'une Transaction ?

Une transaction est une s√©quence d'op√©rations effectu√©es en tant qu'unit√© de travail unique. Ces op√©rations sont souvent des actions de base de donn√©es telles que des insertions, des mises √† jour, des suppressions ou des lectures de donn√©es. L'objectif principal d'une transaction est d'assurer la coh√©rence des donn√©es en garantissant que toutes les op√©rations dans la transaction sont ex√©cut√©es avec succ√®s ou, en cas d'erreur, que toutes les op√©rations sont annul√©es.

#### Propri√©t√©s ACID des Transactions

Les transactions doivent respecter les propri√©t√©s ACID (Atomicit√©, Coh√©rence, Isolation, Durabilit√©) :

1. **Atomicit√©** : Toutes les op√©rations d'une transaction sont ex√©cut√©es ou aucune d'entre elles ne l'est. Si une partie de la transaction √©choue, la transaction enti√®re √©choue, et les modifications sont annul√©es.
2. **Coh√©rence** : Une transaction doit transformer l'√©tat de la base de donn√©es d'un √©tat valide √† un autre √©tat valide, en pr√©servant l'int√©grit√© des contraintes.
3. **Isolation** : Les modifications apport√©es par une transaction ne sont pas visibles aux autres transactions tant que la transaction n'est pas termin√©e.
4. **Durabilit√©** : Une fois qu'une transaction est valid√©e, les modifications apport√©es sont permanentes, m√™me en cas de d√©faillance du syst√®me.

#### Gestion des Transactions en JPA avec Spring

En JPA, les transactions peuvent √™tre g√©r√©es de deux mani√®res principales :

1. **Gestion des transactions d√©clarative** :
   - Utilis√©e avec l'annotation `@Transactional` de Spring.
   - Permet de d√©clarer les limites des transactions directement dans le code en annotant les classes ou les m√©thodes qui doivent √™tre transactionnelles.
   
2. **Gestion des transactions programmatique** :
   - Permet de contr√¥ler explicitement les transactions dans le code en utilisant des API comme `EntityManager` ou `UserTransaction`.
   - Moins couramment utilis√©e, car elle n√©cessite plus de code pour g√©rer explicitement le d√©but, la validation, et l'annulation des transactions.

#### Exemple de gestion transactionnelle avec `@Transactional`

```java
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class CustomerService {

    @Transactional
    public void createCustomer(Customer customer) {
        // Op√©rations transactionnelles
        customerRepository.save(customer);
        accountService.createAccountForCustomer(customer);
    }
}
```

#### Explications

- **`@Transactional`** : Indique que la m√©thode `createCustomer` doit √™tre ex√©cut√©e dans une transaction. Si une exception non v√©rifi√©e (unchecked exception) se produit, la transaction est automatiquement annul√©e.

---

### <a name="propagation-et-isolation-des-transactions"></a> 5.2. Propagation et Isolation des Transactions

#### Propagation des Transactions

La propagation des transactions d√©termine comment une transaction existante se comporte lorsqu'une m√©thode transactionnelle est appel√©e depuis une autre m√©thode transactionnelle. Spring offre plusieurs options de propagation :

1. **`REQUIRED`** (par d√©faut) :
   - La m√©thode utilise la transaction existante si elle est d√©j√† en cours, sinon une nouvelle transaction est cr√©√©e.
   - Exemple : 
   ```java
   @Transactional(propagation = Propagation.REQUIRED)
   public void updateCustomer(Customer customer) {
       // ...
   }
   ```

2. **`REQUIRES_NEW`** :
   - Une nouvelle transaction est toujours cr√©√©e, suspendant la transaction existante.
   - Exemple :
   ```java
   @Transactional(propagation = Propagation.REQUIRES_NEW)
   public void logTransaction(String log) {
       // ...
   }
   ```

3. **`SUPPORTS`** :
   - La m√©thode participe √† la transaction existante si elle est pr√©sente, sinon elle s'ex√©cute en dehors de toute transaction.
   - Exemple :
   ```java
   @Transactional(propagation = Propagation.SUPPORTS)
   public Customer getCustomer(Long id) {
       // ...
   }
   ```

4. **`NOT_SUPPORTED`** :
   - La m√©thode s'ex√©cute toujours en dehors d'une transaction, suspendant toute transaction existante.
   - Exemple :
   ```java
   @Transactional(propagation = Propagation.NOT_SUPPORTED)
   public void performNonTransactionalOperation() {
       // ...
   }
   ```

5. **`MANDATORY`** :
   - La m√©thode doit √™tre appel√©e dans une transaction existante, sinon une exception est lev√©e.
   - Exemple :
   ```java
   @Transactional(propagation = Propagation.MANDATORY)
   public void mandatoryTransactionOperation() {
       // ...
   }
   ```

6. **`NEVER`** :
   - La m√©thode ne doit jamais √™tre ex√©cut√©e dans une transaction. Si une transaction existe, une exception est lev√©e.
   - Exemple :
   ```java
   @Transactional(propagation = Propagation.NEVER)
   public void neverTransactionalOperation() {
       // ...
   }
   ```

7. **`NESTED`** :
   - La m√©thode est ex√©cut√©e dans une transaction imbriqu√©e si une transaction existe, permettant de valider ou d'annuler ind√©pendamment des sous-transactions.
   - Exemple :
   ```java
   @Transactional(propagation = Propagation.NESTED)
   public void nestedTransactionOperation() {
       // ...
   }
   ```

#### Niveaux d'Isolation des Transactions

Les niveaux d'isolation des transactions d√©finissent le degr√© auquel les op√©rations de lecture dans une transaction sont isol√©es des autres transactions en cours. Ils permettent de contr√¥ler les ph√©nom√®nes de concurrence comme les lectures non valid√©es, les lectures r√©p√©t√©es et les lectures fant√¥mes.

1. **`DEFAULT`** :
   - Utilise le niveau d'isolation par d√©faut de la base de donn√©es sous-jacente.

2. **`READ_UNCOMMITTED`** :
   - Permet de lire les donn√©es non valid√©es par d'autres transactions. Risque de lectures non valid√©es, mais am√©liore la performance.
   - Exemple :
   ```java
   @Transactional(isolation = Isolation.READ_UNCOMMITTED)
   public void readUncommittedOperation() {
       // ...
   }
   ```

3. **`READ_COMMITTED`** :
   - Ne permet pas de lire les donn√©es non valid√©es. C'est le niveau d'isolation le plus couramment utilis√© pour √©viter les lectures sales.
   - Exemple :
   ```java
   @Transactional(isolation = Isolation.READ_COMMITTED)
   public void readCommittedOperation() {
       // ...
   }
   ```

4. **`REPEATABLE_READ`** :
   - Assure que les donn√©es lues dans une transaction ne changeront pas si elles sont relues dans la m√™me transaction. Pr√©vient les lectures non r√©p√©t√©es.
   - Exemple :
   ```java
   @Transactional(isolation = Isolation.REPEATABLE_READ)
   public void repeatableReadOperation() {
       // ...
   }
   ```

5. **`SERIALIZABLE`** :
   - Le niveau d'isolation le plus strict. Les transactions sont ex√©cut√©es de mani√®re s√©quentielle, emp√™chant les lectures fant√¥mes mais r√©duisant la concurrence.
   - Exemple :
   ```java
   @Transactional(isolation = Isolation.SERIALIZABLE)
   public void serializableOperation() {
       // ...
   }
   ```

---

### Conclusion

La gestion des transactions est essentielle pour assurer la coh√©rence et l'int√©grit√© des donn√©es dans les applications Java. En combinant les options de propagation des transactions et les niveaux d'isolation, vous pouvez ajuster finement le comportement transactionnel de votre application pour r√©pondre aux exigences sp√©cifiques de votre domaine.



[‚¨ÜÔ∏è Retour en Haut](#jpa)

---
---
---

Voici une version encore plus exhaustive et d√©taill√©e de la section sur les requ√™tes et interactions avec la base de donn√©es en JPA, con√ßue pour des d√©butants complets. Cette version d√©compose chaque concept de mani√®re plus simple, avec des explications approfondies et des exemples faciles √† suivre.

---

## <a name="requetes-et-interactions-avec-la-base-de-donnees"></a> 6. Requ√™tes et Interactions avec la Base de Donn√©es

Lorsqu'on travaille avec des bases de donn√©es en JPA, il est crucial de savoir comment interroger et manipuler les donn√©es persist√©es sous forme d'entit√©s. JPA propose plusieurs m√©thodes pour formuler ces requ√™tes : JPQL (Java Persistence Query Language), l'API Criteria, et les requ√™tes SQL natives. Chacune de ces m√©thodes est adapt√©e √† diff√©rents besoins, et il est important de comprendre leurs diff√©rences et leurs avantages pour les utiliser efficacement.

### <a name="jpql-java-persistence-query-language"></a> 6.1. JPQL (Java Persistence Query Language)

#### Introduction √† JPQL

JPQL est un langage de requ√™te sp√©cialement con√ßu pour JPA. Contrairement au SQL classique, qui interagit directement avec les tables et colonnes de la base de donn√©es, JPQL op√®re sur les entit√©s JPA (c'est-√†-dire les objets Java). Cela signifie que lorsque vous √©crivez une requ√™te JPQL, vous utilisez les noms de vos classes et de leurs champs au lieu des noms de tables et de colonnes. Cette approche rend votre code plus intuitif et portable, car il est ind√©pendant de la structure exacte de la base de donn√©es.

#### Syntaxe de base

La syntaxe de JPQL est tr√®s similaire √† celle du SQL, mais avec quelques diff√©rences notables. Voici un aper√ßu des principales commandes :

- **`SELECT`** : Utilis√©e pour r√©cup√©rer des donn√©es (entit√©s ou attributs) depuis la base de donn√©es.
- **`FROM`** : Sp√©cifie l'entit√© (classe) √† partir de laquelle les donn√©es sont r√©cup√©r√©es.
- **`WHERE`** : Ajoute des conditions pour filtrer les r√©sultats.
- **`JOIN`** : Permet de relier plusieurs entit√©s li√©es.
- **`ORDER BY`** : Trie les r√©sultats selon un ou plusieurs attributs.
- **`GROUP BY`** : Regroupe les r√©sultats selon un ou plusieurs attributs.

#### Exemple pratique : R√©cup√©rer des clients par nom

Imaginons que vous ayez une classe `Customer` avec un champ `lastName`. Pour r√©cup√©rer tous les clients dont le nom de famille est "Dupont", vous pouvez utiliser la requ√™te JPQL suivante :

```java
// D√©finition de l'entit√© Customer
@Entity
@Table(name = "customer")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String lastName;

    private String firstName;

    // Getters et Setters
}

// Requ√™te JPQL pour r√©cup√©rer les clients dont le nom est "Dupont"
String jpql = "SELECT c FROM Customer c WHERE c.lastName = :lastName";
TypedQuery<Customer> query = entityManager.createQuery(jpql, Customer.class);
query.setParameter("lastName", "Dupont");
List<Customer> results = query.getResultList();
```

#### Explications d√©taill√©es

- **`SELECT c FROM Customer c`** : Cette partie de la requ√™te indique que vous voulez s√©lectionner des objets `Customer`. Le `c` est un alias pour `Customer`, qui simplifie l'√©criture de la requ√™te.
- **`WHERE c.lastName = :lastName`** : Ici, vous filtrez les r√©sultats pour ne r√©cup√©rer que les clients dont le champ `lastName` correspond √† "Dupont". Le `:lastName` est un param√®tre nomm√©, ce qui signifie que vous pouvez changer sa valeur √† l'ex√©cution sans modifier la requ√™te.
- **`TypedQuery<Customer>`** : En sp√©cifiant le type `Customer`, vous assurez que la requ√™te retourne une liste d'objets `Customer`, ce qui √©vite les erreurs de type.

#### Joins et Fetching en JPQL

Si un client peut avoir plusieurs cartes (`Card`), vous pourriez vouloir r√©cup√©rer les clients avec leurs cartes associ√©es. Voici comment le faire avec JPQL :

```java
String jpql = "SELECT c FROM Customer c JOIN FETCH c.cards WHERE c.lastName = :lastName";
TypedQuery<Customer> query = entityManager.createQuery(jpql, Customer.class);
query.setParameter("lastName", "Dupont");
List<Customer> results = query.getResultList();
```

- **`JOIN FETCH c.cards`** : Cette clause joint l'entit√© `Customer` avec son association `cards` et indique √† JPA de charger les cartes imm√©diatement avec le client (fetching).

#### Pourquoi utiliser JPQL ?

- **Abstraction** : Vous travaillez avec des entit√©s Java plut√¥t qu'avec des tables de base de donn√©es, ce qui simplifie le code et le rend plus lisible.
- **Portabilit√©** : Comme JPQL est ind√©pendant du SGBD sous-jacent, votre code est plus facilement portable entre diff√©rentes bases de donn√©es.

---

### <a name="criteria-api"></a> 6.2. Criteria API

#### Introduction √† l'API Criteria

L'API Criteria est une alternative programmatique √† JPQL. Au lieu d'√©crire des requ√™tes sous forme de cha√Ænes de caract√®res, vous construisez des requ√™tes dynamiquement en utilisant des objets Java. Cette approche est particuli√®rement utile pour les sc√©narios o√π les requ√™tes doivent √™tre construites conditionnellement, ou lorsqu'elles sont trop complexes pour √™tre √©crites simplement en JPQL.

#### Exemple pratique : R√©cup√©rer des clients par nom

Prenons le m√™me exemple que pr√©c√©demment, mais cette fois en utilisant l'API Criteria :

```java
// Obtenez un CriteriaBuilder √† partir de l'EntityManager
CriteriaBuilder cb = entityManager.getCriteriaBuilder();
// Cr√©ez un CriteriaQuery pour sp√©cifier le type de r√©sultat attendu
CriteriaQuery<Customer> cq = cb.createQuery(Customer.class);
// Sp√©cifiez la racine de la requ√™te (l'entit√© √† partir de laquelle vous partez)
Root<Customer> customer = cq.from(Customer.class);
// Construisez la requ√™te avec une condition
cq.select(customer).where(cb.equal(customer.get("lastName"), "Dupont"));

// Ex√©cutez la requ√™te et r√©cup√©rez les r√©sultats
TypedQuery<Customer> query = entityManager.createQuery(cq);
List<Customer> results = query.getResultList();
```

#### Explications d√©taill√©es

- **`CriteriaBuilder`** : Cet objet est le point d'entr√©e pour cr√©er des requ√™tes Criteria. Il fournit des m√©thodes pour construire des conditions, des agr√©gats, des tris, etc.
- **`CriteriaQuery<Customer>`** : Sp√©cifie le type de retour de la requ√™te (ici, des objets `Customer`).
- **`Root<Customer> customer`** : Repr√©sente la racine de la requ√™te, c'est-√†-dire l'entit√© principale √† partir de laquelle les autres relations et conditions sont √©tablies.
- **`cb.equal(customer.get("lastName"), "Dupont")`** : Cr√©e une condition d'√©galit√© sur le champ `lastName`.

#### Combinaison de crit√®res

L'un des avantages majeurs de l'API Criteria est la facilit√© avec laquelle vous pouvez combiner plusieurs crit√®res :

```java
cq.select(customer)
  .where(
      cb.and(
          cb.equal(customer.get("lastName"), "Dupont"),
          cb.like(customer.get("firstName"), "J%")
      )
  );
```

- **`cb.and`** : Combine plusieurs conditions avec un "ET" logique, ce qui signifie que toutes les conditions doivent √™tre vraies pour qu'un r√©sultat soit retourn√©.
- **`cb.like`** : Ajoute une condition de type "LIKE", qui est similaire √† l'op√©rateur SQL `LIKE`. Ici, il filtre les pr√©noms commen√ßant par "J".

#### Pourquoi utiliser l'API Criteria ?

- **Type-safety** : Comme vous utilisez des objets Java pour construire vos requ√™tes, les erreurs de syntaxe sont d√©tect√©es √† la compilation plut√¥t qu'√† l'ex√©cution.
- **Flexibilit√©** : Vous pouvez construire des requ√™tes dynamiques en fonction des besoins de votre application, ce qui est particuli√®rement utile dans des situations complexes.

---

### <a name="requetes-native-sql"></a> 6.3. Requ√™tes Native SQL

#### Introduction aux requ√™tes SQL natives

Les requ√™tes SQL natives vous permettent d'ex√©cuter du SQL pur directement sur la base de donn√©es sous-jacente. Cela peut √™tre n√©cessaire pour des requ√™tes tr√®s sp√©cifiques, complexes ou pour tirer parti de fonctionnalit√©s propres √† un SGBD particulier. Toutefois, cette m√©thode sacrifie la portabilit√© de votre application, car le SQL peut ne pas √™tre compatible entre diff√©rents syst√®mes de gestion de bases de donn√©es (SGBD).

#### Exemple pratique : R√©cup√©rer des clients par nom

Voici comment vous pourriez √©crire une requ√™te SQL native pour r√©cup√©rer des clients :

```java
// Requ√™te SQL native pour r√©cup√©rer les clients dont le nom est "Dupont"
String sql = "SELECT * FROM customer WHERE last_name = :lastName";
Query query = entityManager.createNativeQuery(sql, Customer.class);
query.setParameter("lastName", "Dupont");
List<Customer> results = query.getResultList();
```

#### Explications d√©taill√©es

- **`createNativeQuery(sql, Customer.class)`** : Cr√©e une requ√™te SQL native. Le deuxi√®me param√®tre indique que les r√©sultats doivent √™tre mapp√©s √† l'entit√© `Customer`.
- **`setParameter("lastName", "Dupont")`** : Rem

place le param√®tre `:lastName` dans la requ√™te par "Dupont".

#### Avantages et inconv√©nients des requ√™tes SQL natives

- **Avantages** :
  - **Acc√®s direct** : Permet d'exploiter pleinement les fonctionnalit√©s avanc√©es et sp√©cifiques de la base de donn√©es.
  - **Performance** : Peut √™tre plus performant pour des requ√™tes complexes ou des op√©rations sp√©cifiques au SGBD.
- **Inconv√©nients** :
  - **Non-portabilit√©** : Le SQL peut ne pas √™tre compatible entre diff√©rents SGBD.
  - **S√©curit√© et Maintenance** : Le code SQL natif doit √™tre maintenu s√©par√©ment du code Java, ce qui peut rendre le code plus difficile √† g√©rer et plus sujet aux erreurs.

#### Requ√™tes natives avec r√©sultats scalaires

Vous pouvez √©galement utiliser des requ√™tes SQL natives pour retourner des r√©sultats scalaires, comme un comptage :

```java
// Requ√™te SQL native pour compter le nombre de clients dont le nom est "Dupont"
String sql = "SELECT COUNT(*) FROM customer WHERE last_name = :lastName";
Query query = entityManager.createNativeQuery(sql);
query.setParameter("lastName", "Dupont");
Long count = (Long) query.getSingleResult();
```

- **`getSingleResult()`** : Utilis√© pour r√©cup√©rer un r√©sultat unique (ici, le comptage).

---

### Conclusion

La ma√Ætrise des diff√©rentes m√©thodes pour interagir avec la base de donn√©es en JPA est essentielle pour d√©velopper des applications robustes et performantes. JPQL est id√©al pour des requ√™tes simples et portables, l'API Criteria offre une flexibilit√© et une s√©curit√© de type, tandis que les requ√™tes SQL natives permettent d'exploiter pleinement la puissance du SGBD sous-jacent.

En comprenant ces outils et en sachant quand les utiliser, vous serez mieux √©quip√© pour r√©pondre aux besoins sp√©cifiques de votre application tout en maintenant un code propre et maintenable.


[‚¨ÜÔ∏è Retour en Haut](#jpa)

---


## <a name="optimisation-des-performances"></a> 7. Optimisation des Performances

L'optimisation des performances est une √©tape cruciale lors de la cr√©ation d'applications utilisant JPA. Une mauvaise gestion des performances peut entra√Æner des ralentissements, une surcharge de la base de donn√©es, ou des temps de r√©ponse longs pour les utilisateurs. Deux concepts importants pour l'optimisation des performances en JPA sont le "Lazy Loading" et le "Eager Loading", ainsi que la mise en place de m√©canismes de caching.

### <a name="lazy-vs-eager-loading"></a> 7.1. Lazy vs Eager Loading

#### Introduction aux chargements paresseux (Lazy) et imm√©diats (Eager)

Lorsque vous travaillez avec des entit√©s li√©es entre elles (par exemple, un `Customer` avec plusieurs `Card`s), JPA doit d√©cider comment et quand charger ces entit√©s associ√©es √† partir de la base de donn√©es. Il existe deux strat√©gies principales pour cela : 

1. **Lazy Loading** (chargement paresseux) : L'entit√© associ√©e n'est charg√©e que lorsque vous en avez r√©ellement besoin. 
2. **Eager Loading** (chargement imm√©diat) : L'entit√© associ√©e est charg√©e imm√©diatement en m√™me temps que l'entit√© principale.

#### Pourquoi ces concepts sont-ils importants ?

- **Performance** : Une mauvaise utilisation du Lazy ou Eager Loading peut entra√Æner une surcharge inutile sur la base de donn√©es ou un nombre excessif de requ√™tes.
- **M√©moire** : Charger trop de donn√©es non n√©cessaires peut √©galement consommer beaucoup de m√©moire, ralentissant ainsi l'application.

#### Exemples concrets

Imaginons que vous ayez un client (`Customer`) et que ce client poss√®de plusieurs cartes (`Card`). Voici un exemple de la fa√ßon dont cela pourrait √™tre configur√© en JPA.

```java
@Entity
@Table(name = "customer")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToMany(mappedBy = "customer", fetch = FetchType.LAZY) // Lazy Loading
    private List<Card> cards;

    // Getters et Setters
}

@Entity
@Table(name = "card")
public class Card {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String cardNumber;

    @ManyToOne
    @JoinColumn(name = "customer_id")
    private Customer customer;

    // Getters et Setters
}
```

#### Explications d√©taill√©es

- **Lazy Loading (`FetchType.LAZY`)** : Dans cet exemple, les cartes (`cards`) associ√©es √† un client (`Customer`) ne sont charg√©es que lorsque vous acc√©dez explicitement √† la propri√©t√© `cards`. Cela signifie que si vous r√©cup√©rez un client mais que vous ne demandez pas ses cartes, elles ne seront pas charg√©es, √©conomisant ainsi des ressources.

  ```java
  Customer customer = entityManager.find(Customer.class, 1L);
  // Les cartes ne sont pas encore charg√©es ici
  List<Card> cards = customer.getCards(); // Les cartes sont charg√©es ici
  ```

- **Eager Loading (`FetchType.EAGER`)** : Si vous changez `FetchType.LAZY` en `FetchType.EAGER`, les cartes seront charg√©es imm√©diatement avec le client, m√™me si vous ne les utilisez pas tout de suite.

  ```java
  @OneToMany(mappedBy = "customer", fetch = FetchType.EAGER) // Eager Loading
  private List<Card> cards;
  ```

  Dans ce cas, d√®s que vous r√©cup√©rez un client, toutes ses cartes sont √©galement r√©cup√©r√©es.

  ```java
  Customer customer = entityManager.find(Customer.class, 1L);
  // Les cartes sont d√©j√† charg√©es ici
  List<Card> cards = customer.getCards();
  ```

#### Quand utiliser Lazy Loading ?

- **Utilisez Lazy Loading** lorsque vous n'avez pas besoin des donn√©es associ√©es imm√©diatement. Par exemple, si vous avez une liste de clients √† afficher sans les d√©tails des cartes, Lazy Loading √©vitera de charger toutes les cartes inutilement.

#### Quand utiliser Eager Loading ?

- **Utilisez Eager Loading** lorsque vous savez que vous aurez besoin des donn√©es associ√©es imm√©diatement apr√®s la r√©cup√©ration de l'entit√© principale. Par exemple, si vous affichez un client et toutes ses cartes sur la m√™me page, Eager Loading peut √™tre plus efficace.

#### Erreurs courantes et pi√®ges

- **LazyInitializationException** : Si vous utilisez Lazy Loading et que vous essayez d'acc√©der aux entit√©s associ√©es en dehors de la transaction ou du contexte de persistance, JPA ne pourra pas les charger et lancera une LazyInitializationException. Il est important de g√©rer correctement le cycle de vie des transactions pour √©viter ce probl√®me.

---

### <a name="caching-avec-jpa"></a> 7.2. Caching avec JPA

#### Introduction au Caching

Le caching est une technique utilis√©e pour am√©liorer les performances en r√©duisant le nombre de requ√™tes envoy√©es √† la base de donn√©es. Au lieu de demander des donn√©es √† la base de donn√©es chaque fois qu'une requ√™te est effectu√©e, JPA peut stocker temporairement les donn√©es fr√©quemment utilis√©es dans un cache, rendant les acc√®s suivants plus rapides.

#### Types de Caching en JPA

1. **Cache de premier niveau (First-Level Cache)** :
   - **Qu'est-ce que c'est ?** : C'est un cache qui est activ√© par d√©faut dans JPA et qui est associ√© √† l'`EntityManager`. Les entit√©s charg√©es dans une session `EntityManager` sont mises en cache, et si vous demandez la m√™me entit√© dans la m√™me session, JPA utilisera l'entit√© mise en cache au lieu de la recharger depuis la base de donn√©es.
   - **Port√©e** : Le cache de premier niveau est li√© au cycle de vie de l'`EntityManager`. Une fois que l'`EntityManager` est ferm√©, le cache est perdu.

   Exemple :

   ```java
   EntityManager em = entityManagerFactory.createEntityManager();
   Customer customer1 = em.find(Customer.class, 1L);
   Customer customer2 = em.find(Customer.class, 1L); // La m√™me entit√© est r√©cup√©r√©e du cache
   ```

2. **Cache de second niveau (Second-Level Cache)** :
   - **Qu'est-ce que c'est ?** : C'est un cache optionnel qui peut √™tre configur√© pour √™tre partag√© entre plusieurs sessions `EntityManager`. Ce cache est g√©r√© par le fournisseur de JPA (comme Hibernate) et peut √™tre utilis√© pour stocker les entit√©s au-del√† de la port√©e d'une seule session `EntityManager`.
   - **Port√©e** : Le cache de second niveau est global √† l'application et peut √™tre partag√© entre plusieurs instances d'`EntityManager`.

   Pour activer le cache de second niveau avec Hibernate, vous devez le configurer dans votre fichier de configuration :

   ```properties
   hibernate.cache.use_second_level_cache=true
   hibernate.cache.region.factory_class=org.hibernate.cache.jcache.JCacheRegionFactory
   ```

   Et annoter les entit√©s que vous souhaitez mettre en cache :

   ```java
   @Entity
   @Cacheable // Active le cache de second niveau pour cette entit√©
   public class Customer {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       private String name;
       // Getters et Setters
   }
   ```

#### Avantages du Caching

- **R√©duction de la charge sur la base de donn√©es** : Moins de requ√™tes √† la base de donn√©es signifie que la base de donn√©es est moins sollicit√©e, ce qui peut am√©liorer les performances globales de l'application.
- **Temps de r√©ponse plus rapide** : Les donn√©es mises en cache peuvent √™tre retourn√©es beaucoup plus rapidement que si elles devaient √™tre recharg√©es depuis la base de donn√©es √† chaque fois.

#### Inconv√©nients du Caching

- **Consommation de m√©moire** : Le caching utilise de la m√©moire pour stocker les donn√©es, ce qui peut √™tre un probl√®me si vous avez un grand nombre de donn√©es.
- **Coh√©rence des donn√©es** : Si les donn√©es dans la base de donn√©es changent mais que le cache n'est pas mis √† jour, votre application pourrait utiliser des donn√©es obsol√®tes.

#### Erreurs courantes et pi√®ges

- **Cache Stale** : Si le cache n'est pas correctement invalid√© ou rafra√Æchi, il peut contenir des donn√©es obsol√®tes, ce qui peut entra√Æner des erreurs ou des comportements inattendus.
- **Mauvaise configuration** : Un cache mal configur√© peut entra√Æner une surconsommation de m√©moire ou m√™me ralentir l'application au lieu de l'acc√©l√©rer.

---

### Conclusion

L'optimisation des performances en JPA repose en grande partie sur la compr√©hension et la bonne utilisation du Lazy et Eager Loading ainsi que des m√©canismes de caching. Ces concepts, lorsqu'ils sont correctement appliqu√©s, peuvent consid√©rablement am√©liorer la r√©activit√© et l'efficacit√© de votre application, en r√©duisant la charge sur la base de donn√©es et en am√©liorant les temps de r√©ponse.

[‚¨ÜÔ∏è Retour en Haut](#jpa)



---
---
---



## <a name="validation-des-donnees"></a> 8. Validation des Donn√©es

La validation des donn√©es est un aspect crucial dans le d√©veloppement d'applications pour s'assurer que les donn√©es manipul√©es et stock√©es sont correctes et coh√©rentes. En JPA, la validation des donn√©es peut √™tre int√©gr√©e directement dans les entit√©s √† l'aide de la sp√©cification **Bean Validation**. Cela permet de d√©finir des r√®gles de validation sur les champs de vos entit√©s, garantissant ainsi que les donn√©es soient conformes avant d'√™tre persist√©es dans la base de donn√©es.

### <a name="utilisation-de-bean-validation"></a> 8.1. Utilisation de Bean Validation

#### Introduction √† Bean Validation

**Bean Validation** est une sp√©cification Java standard pour valider les objets de mani√®re d√©clarative en utilisant des annotations. Ces annotations sont plac√©es sur les champs ou les m√©thodes de vos classes d'entit√©s, et elles permettent de d√©finir des contraintes que les donn√©es doivent respecter.

#### Pourquoi la validation des donn√©es est-elle importante ?

- **Int√©grit√© des donn√©es** : Emp√™che les donn√©es incorrectes ou incompl√®tes d'√™tre stock√©es dans la base de donn√©es.
- **S√©curit√©** : R√©duit le risque d'injections malveillantes en validant les entr√©es utilisateur.
- **Qualit√© du code** : Centralise les r√®gles de validation dans les entit√©s, rendant le code plus propre et plus facile √† maintenir.

#### Exemple pratique : Validation des donn√©es pour une entit√© `Customer`

Prenons un exemple simple o√π nous avons une entit√© `Customer` avec quelques champs qui doivent √™tre valid√©s :

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

@Entity
@Table(name = "customer")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull(message = "Le nom ne peut pas √™tre nul")
    @Size(min = 2, max = 30, message = "Le nom doit √™tre entre 2 et 30 caract√®res")
    private String lastName;

    @NotNull(message = "Le pr√©nom ne peut pas √™tre nul")
    @Size(min = 2, max = 30, message = "Le pr√©nom doit √™tre entre 2 et 30 caract√®res")
    private String firstName;

    @Email(message = "L'email doit √™tre valide")
    private String email;

    // Getters et Setters
}
```

#### Explications d√©taill√©es

- **`@NotNull`** : Cette annotation garantit que le champ ne peut pas √™tre nul. Par exemple, le champ `lastName` ne peut pas √™tre `null`. Si vous essayez de persister un `Customer` sans nom, une erreur sera lev√©e.
- **`@Size(min = 2, max = 30)`** : Cette annotation garantit que la longueur du champ est comprise entre un minimum et un maximum sp√©cifi√©s. Ici, le nom de famille (`lastName`) doit comporter entre 2 et 30 caract√®res.
- **`@Email`** : Cette annotation valide que le champ `email` contient une adresse email au format correct.

#### Utilisation des annotations de validation courantes

Voici quelques autres annotations couramment utilis√©es en Bean Validation :

- **`@Min(value = 18)`** : Sp√©cifie qu'un nombre doit √™tre au moins √©gal √† une valeur minimale. Utile pour les champs d'√¢ge, par exemple.
- **`@Max(value = 100)`** : Sp√©cifie qu'un nombre doit √™tre au plus √©gal √† une valeur maximale.
- **`@Pattern(regexp = "regex")`** : Valide que la valeur correspond √† une expression r√©guli√®re (regex). Par exemple, pour valider un num√©ro de t√©l√©phone.
- **`@Past`** : S'assure qu'une date est dans le pass√©. Utilis√© pour valider les dates de naissance, par exemple.
- **`@Future`** : S'assure qu'une date est dans le futur. Utile pour des champs de r√©servation ou de rendez-vous.

#### Validation automatique avec JPA

Lorsque vous utilisez JPA avec Bean Validation, les validations sont automatiquement appliqu√©es avant que les entit√©s ne soient persist√©es (enregistr√©es dans la base de donn√©es). Si une entit√© ne respecte pas les contraintes de validation, une exception de type `ConstraintViolationException` est lev√©e, emp√™chant ainsi la transaction de se terminer avec des donn√©es invalides.

Exemple :

```java
Customer customer = new Customer();
customer.setLastName("Du"); // Trop court
customer.setFirstName(null); // Null, invalide
customer.setEmail("invalid-email"); // Format email invalide

try {
    entityManager.persist(customer);
} catch (ConstraintViolationException e) {
    // Gestion de l'exception
    e.getConstraintViolations().forEach(violation -> {
        System.out.println(violation.getPropertyPath() + " " + violation.getMessage());
    });
}
```

#### Validation personnalis√©e

Il est √©galement possible de cr√©er des validations personnalis√©es en d√©finissant vos propres annotations et validateurs. Par exemple, vous pourriez cr√©er une annotation pour valider un num√©ro de carte de cr√©dit selon un algorithme sp√©cifique.

```java
@Target({ ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CreditCardValidator.class)
public @interface ValidCreditCard {
    String message() default "Num√©ro de carte de cr√©dit invalide";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public class CreditCardValidator implements ConstraintValidator<ValidCreditCard, String> {
    @Override
    public void initialize(ValidCreditCard constraintAnnotation) {}

    @Override
    public boolean isValid(String creditCardNumber, ConstraintValidatorContext context) {
        // Impl√©mentez votre algorithme de validation de carte de cr√©dit ici
        return true; // Retourne true si valide, sinon false
    }
}
```

#### Int√©gration avec Spring Boot

Si vous utilisez Spring Boot, la validation Bean Validation est automatiquement prise en charge. Les validations sont appliqu√©es non seulement lors de la persistance des entit√©s, mais aussi lors de la validation des objets en entr√©e dans les contr√¥leurs REST.

Exemple :

```java
@RestController
public class CustomerController {

    @PostMapping("/customers")
    public ResponseEntity<Customer> createCustomer(@Valid @RequestBody Customer customer) {
        // Si l'objet Customer est invalide, une exception est lev√©e automatiquement
        return ResponseEntity.ok(customerService.save(customer));
    }
}
```

- **`@Valid`** : Cette annotation garantit que l'objet `Customer` pass√© au contr√¥leur est valid√© avant que le code du contr√¥leur ne soit ex√©cut√©.

#### Erreurs courantes et pi√®ges

- **Oublier `@Valid` dans les contr√¥leurs** : Si vous oubliez de placer l'annotation `@Valid` sur un param√®tre d'entr√©e dans un contr√¥leur, les validations ne seront pas appliqu√©es, et les donn√©es invalides pourraient √™tre persist√©es.
- **Mauvaise gestion des exceptions** : Si vous ne g√©rez pas correctement les exceptions de validation (comme `ConstraintViolationException`), les utilisateurs peuvent recevoir des messages d'erreur peu clairs ou non informatifs.

---

### Conclusion

La validation des donn√©es est une partie essentielle de la cr√©ation d'applications robustes et s√©curis√©es. Bean Validation, int√©gr√© avec JPA, offre un moyen simple et efficace de s'assurer que vos entit√©s sont toujours dans un √©tat valide avant d'√™tre persist√©es. En utilisant les annotations standard et personnalis√©es, vous pouvez d√©finir des r√®gles de validation pr√©cises et les appliquer de mani√®re coh√©rente dans toute votre application.






[‚¨ÜÔ∏è Retour en Haut](#jpa)

---
---
---


# <a name="gestion-des-historiques-avec-hibernate-envers"></a> 9. Gestion des Historiques avec Hibernate Envers

Dans cette section, vous apprendrez √† utiliser Hibernate Envers pour g√©rer les versions des entit√©s dans votre application. Vous verrez comment configurer Envers pour suivre les modifications apport√©es aux entit√©s et comment r√©cup√©rer les versions pr√©c√©dentes des donn√©es √† des fins d'audit ou de gestion des historiques.

---

### <a name="introduction-a-hibernate-envers"></a> 9.1. Introduction √† Hibernate Envers

**Hibernate Envers** est une extension de Hibernate qui permet de suivre les modifications apport√©es aux entit√©s dans une application. Il enregistre chaque modification sous forme de version, permettant ainsi de revenir en arri√®re pour visualiser l'√©tat d'une entit√© √† un moment donn√©. Cela est particuli√®rement utile pour les besoins d'audit, de gestion des versions, ou de conformit√© r√©glementaire.

#### Objectifs de Hibernate Envers :
- **Suivi des Changements** : Garder une trace des modifications apport√©es aux entit√©s.
- **Audit des Donn√©es** : R√©cup√©rer les versions ant√©rieures des entit√©s pour des besoins d'audit.
- **Gestion des Versions** : Comparer diff√©rentes versions d'une entit√© et restaurer des √©tats ant√©rieurs si n√©cessaire.

#### Fonctionnement de Hibernate Envers :
- Envers ajoute automatiquement une table d'historique pour chaque entit√© annot√©e avec `@Audited`.
- Chaque op√©ration de `INSERT`, `UPDATE`, ou `DELETE` est enregistr√©e dans ces tables d'historique.
- Les tables d'historique stockent l'√©tat de l'entit√© pour chaque r√©vision (version).

### <a name="configuration-de-hibernate-envers"></a> 9.2. Configuration de Hibernate Envers

#### 9.2.1. Ajouter la D√©pendance Hibernate Envers

Pour utiliser Hibernate Envers, vous devez ajouter la d√©pendance appropri√©e dans votre fichier `pom.xml`.

```xml
<dependencies>
    <!-- D√©pendance pour Hibernate Envers -->
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-envers</artifactId>
        <version>5.4.31.Final</version>
    </dependency>
</dependencies>
```

#### 9.2.2. Annoter les Entit√©s pour l'Audit

Pour commencer √† suivre les versions des entit√©s, il vous suffit d'annoter les classes d'entit√© avec `@Audited`.

**Exemple :**

```java
package com.example.demo.model;

import org.hibernate.envers.Audited;
import jakarta.persistence.*;

@Entity
@Table(name = "customer")
@Audited // Annotation pour activer l'audit sur cette entit√©
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "customer_id")
    private int customerId;

    @Column(name = "customer_last_name")
    private String customerLastName;

    @Column(name = "customer_first_name")
    private String customerFirstName;

    // Constructeurs, getters, et setters
}
```

#### 9.2.3. Configuration des Propri√©t√©s Hibernate pour Envers

Vous devez √©galement configurer certaines propri√©t√©s dans le fichier `application.properties` ou `application.yml` pour que Hibernate Envers fonctionne correctement.

**Exemple de configuration dans `application.properties` :**

```properties
# Configuration des audits
hibernate.ejb.event.post-insert = org.hibernate.ejb.event.EJB3PostInsertEventListener, org.hibernate.envers.event.AuditEventListener
hibernate.ejb.event.post-update = org.hibernate.ejb.event.EJB3PostUpdateEventListener, org.hibernate.envers.event.AuditEventListener
hibernate.ejb.event.post-delete = org.hibernate.ejb.event.EJB3PostDeleteEventListener, org.hibernate.envers.event.AuditEventListener
hibernate.ejb.event.pre-collection-update = org.hibernate.envers.event.AuditEventListener
hibernate.ejb.event.pre-collection-remove = org.hibernate.envers.event.AuditEventListener
hibernate.ejb.event.post-collection-recreate = org.hibernate.envers.event.AuditEventListener
```

### <a name="exemples-dutilisation"></a> 9.3. Exemples d'Utilisation

#### 9.3.1. Suivi des Versions d'Entit√©s

Une fois Envers configur√©, chaque modification d'une entit√© sera automatiquement suivie. Vous pouvez ensuite r√©cup√©rer l'historique d'une entit√© avec quelques lignes de code.

**Exemple de r√©cup√©ration des versions d'une entit√© `Customer` :**

```java
package com.example.demo.service;

import org.hibernate.envers.AuditReader;
import org.hibernate.envers.AuditReaderFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;

import java.util.List;

@Service
public class CustomerAuditService {

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional
    public List<Number> getRevisions(Integer customerId) {
        AuditReader auditReader = AuditReaderFactory.get(entityManager);
        return auditReader.getRevisions(Customer.class, customerId);
    }

    @Transactional
    public Customer getCustomerAtRevision(Integer customerId, Number revision) {
        AuditReader auditReader = AuditReaderFactory.get(entityManager);
        return auditReader.find(Customer.class, customerId, revision);
    }
}
```

**Explication :**
- **AuditReaderFactory** : Cr√©e un AuditReader, qui est utilis√© pour lire les r√©visions des entit√©s.
- **getRevisions** : Retourne la liste des r√©visions pour une entit√© donn√©e.
- **getCustomerAtRevision** : Retourne l'√©tat d'une entit√© `Customer` √† une r√©vision sp√©cifique.

#### 9.3.2. Comparaison des R√©visions

Envers permet √©galement de comparer diff√©rentes versions d'une entit√© pour voir ce qui a chang√© entre deux r√©visions.

**Exemple :**

```java
package com.example.demo.service;

import org.hibernate.envers.AuditReader;
import org.hibernate.envers.AuditReaderFactory;
import org.hibernate.envers.query.AuditEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;

import java.util.List;

@Service
public class CustomerAuditComparisonService {

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional
    public List<Object[]> compareRevisions(Integer customerId) {
        AuditReader auditReader = AuditReaderFactory.get(entityManager);

        return auditReader.createQuery()
            .forRevisionsOfEntity(Customer.class, false, true)
            .add(AuditEntity.id().eq(customerId))
            .getResultList();
    }
}
```

**Explication :**
- **AuditEntity** : Utilis√© pour ajouter des crit√®res √† une requ√™te d'audit.
- **forRevisionsOfEntity** : Permet de r√©cup√©rer les versions d'une entit√© et de les comparer.

---
---
---

[‚¨ÜÔ∏è Retour en Haut](#jpa)



---

## <a name="conclusion-et-ressources-complementaires"></a> 10. Conclusion et Ressources Compl√©mentaires

### R√©capitulatif et Ressources
- R√©capitulatif des concepts abord√©s avec des liens vers des ressources suppl√©mentaires pour approfondir la ma√Ætrise de JPA.
- Je vous pr√©sente une table r√©capitulative des concepts principaux li√©s √† JPA et Hibernate sous forme de tableau comparatif :

| **Concept**                    | **Description**                                                                 | **Exemple**                                                   |
| ------------------------------ | ------------------------------------------------------------------------------- | ------------------------------------------------------------- |
| **JPA (Java Persistence API)** | Sp√©cification Java standard pour le mapping objet-relationnel (ORM).            | D√©finit les annotations comme `@Entity`, `@Id`, `@OneToMany`. |
| **Hibernate**                  | Framework qui impl√©mente JPA et offre des fonctionnalit√©s suppl√©mentaires.      | Impl√©mente JPA, ajoute des extensions comme Hibernate Envers. |
| **@Entity**                    | Annotation JPA indiquant qu'une classe est une entit√© persistante.              | `@Entity public class Customer { ... }`                       |
| **@Table**                     | Annotation pour sp√©cifier le nom de la table de base de donn√©es associ√©e.       | `@Table(name = "customer")`                                   |
| **@Id**                        | Annotation pour d√©finir la cl√© primaire d'une entit√©.                           | `@Id private Long id;`                                        |
| **@GeneratedValue**            | Annotation pour indiquer la strat√©gie de g√©n√©ration de la cl√© primaire.         | `@GeneratedValue(strategy = GenerationType.IDENTITY)`         |
| **Lazy Loading**               | Strat√©gie de chargement diff√©r√© des entit√©s associ√©es.                          | `@OneToMany(fetch = FetchType.LAZY)`                          |
| **Eager Loading**              | Strat√©gie de chargement imm√©diat des entit√©s associ√©es.                         | `@OneToMany(fetch = FetchType.EAGER)`                         |
| **JPQL**                       | Langage de requ√™te orient√© objet pour interroger des entit√©s JPA.               | `SELECT c FROM Customer c WHERE c.lastName = 'Dupont'`        |
| **Criteria API**               | API type-safe pour construire des requ√™tes dynamiques en JPA.                   | `CriteriaBuilder cb = entityManager.getCriteriaBuilder(); ...` |
| **Requ√™tes SQL natives**       | Requ√™tes SQL directement ex√©cut√©es sur la base de donn√©es via JPA/Hibernate.    | `String sql = "SELECT * FROM customer";`                      |
| **Hibernate Envers**           | Extension de Hibernate pour la gestion des versions et de l'audit des entit√©s.  | `@Audited`                                                    |
| **Cache de premier niveau**    | Cache automatique associ√© √† l'EntityManager pour les entit√©s persist√©es.        | Stockage des entit√©s dans l'EntityManager.                    |
| **Cache de second niveau**     | Cache partag√© entre plusieurs sessions EntityManager pour am√©liorer les performances. | Configuration dans `application.properties`.               |


- Je vous recommande aussi une s√©lection de livres recommand√©s pour approfondir vos connaissances sur Hibernate et JPA :

## Livres en anglais

- **Java Persistence with Hibernate, Second Edition** par Christian Bauer, Gavin King et Gary Gregory[7]. Ce livre explore Hibernate 5 en d√©tail avec le standard JPA 2.1. Il couvre de nombreux exemples pratiques.

- **High-Performance Java Persistence** par Vlad Mihalcea[7]. Ce livre se concentre sur l'optimisation des performances avec JPA et Hibernate, en explorant les m√©canismes internes.

- **Harnessing Hibernate** par James Elliott, Timothy M. O'Brien et Ryan Fowler[7]. Une introduction pratique √† Hibernate √† travers une s√©rie de projets concrets.

## Livres en fran√ßais  

- **JPA et Java Hibernate - Apprenez le mapping objet-relationnel (ORM) avec Java** par Martial Banon[6][8]. Ce livre couvre les concepts des ORM et guide le lecteur pas √† pas dans la cr√©ation d'une application avec JPA/Hibernate.

## Ressources en ligne

- **Hibernate Tips: More than 70 solutions to common Hibernate problems** par Thorben Janssen[7]. Un recueil de conseils pratiques pour r√©soudre des probl√®mes courants avec Hibernate.

- Le site officiel d'Hibernate propose √©galement une liste de livres recommand√©s[7].

Ces ressources vous permettront d'approfondir vos connaissances sur JPA et Hibernate, des concepts de base aux fonctionnalit√©s avanc√©es. Je vous recommande de commencer par un ouvrage introductif comme celui de Martial Banon si vous d√©butez, puis de passer √† des livres plus sp√©cialis√©s selon vos besoins.

### Citations:

[1] https://www.baeldung.com/learn-jpa-hibernate 

[2] https://dzone.com/articles/getting-started-with-jpahibernate

[3] https://www.geeksforgeeks.org/hibernate-example-using-jpa-and-mysql/

[4] https://www.springboottutorial.com/jpa-hibernate-tutorial-for-beginners

[5] https://www.codejava.net/frameworks/hibernate/java-hibernate-jpa-annotations-tutorial-for-beginners

[6] https://www.prologue.ca/698268-24-livre-Informatique/JPA_et_Java_Hibernate_-_Apprenez_le_mapping_objet-relationnel__ORM__avec_Java.html?pRetour=00_100

[7] https://hibernate.org/orm/books/

[8] https://www.editions-eni.fr/livre/jpa-et-java-hibernate-apprenez-le-mapping-objet-relationnel-orm-avec-java-9782409005824




[‚¨ÜÔ∏è Retour en Haut](#jpa)




































---
---
---

# Annexe 1 - Exigences pour que le mapping avec JPA fonctionne
---

### Contenu suppl√©mentaire pour la section 1 : Exigences et Pr√©-requis Techniques pour Utiliser JPA

### Exigences pour Utiliser JPA dans une Application Java

Pour que JPA fonctionne correctement dans une application Java, il est essentiel de respecter certaines exigences techniques. Ces exigences concernent les annotations, les constructeurs, les m√©thodes getter et setter, ainsi que la configuration du projet via le fichier `pom.xml`.

#### 1. Annotations Essentielles

JPA repose fortement sur les annotations pour le mapping objet-relationnel (ORM). Voici quelques-unes des annotations les plus importantes √† conna√Ætre :

- **`@Entity`** : Cette annotation est utilis√©e pour indiquer qu'une classe Java est une entit√© JPA. Elle sera mapp√©e √† une table de la base de donn√©es.
  
- **`@Table(name = "table_name")`** : Optionnelle mais recommand√©e, elle permet de sp√©cifier le nom de la table dans la base de donn√©es qui correspond √† l'entit√©.
  
- **`@Id`** : Elle est utilis√©e pour indiquer le champ qui sert de cl√© primaire dans la base de donn√©es.

- **`@GeneratedValue(strategy = GenerationType.IDENTITY)`** : Cette annotation indique que la valeur de la cl√© primaire est g√©n√©r√©e automatiquement par la base de donn√©es.

- **`@Column(name = "column_name")`** : Permet de sp√©cifier le nom de la colonne dans la table de la base de donn√©es √† laquelle un champ est mapp√©.

#### Exemple d'Entit√© avec Annotations

```java
@Entity
@Table(name = "customer")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "customer_id")
    private int customerId;

    @Column(name = "customer_last_name")
    private String customerLastName;

    @Column(name = "customer_first_name")
    private String customerFirstName;

    // Constructeurs, Getters et Setters...
}
```

#### 2. Constructeurs

Pour que JPA fonctionne correctement, chaque entit√© doit avoir un **constructeur par d√©faut** (sans param√®tres). Cela permet √† JPA de cr√©er des instances d'entit√©s lors du processus de persistance.

- **Constructeur par d√©faut** : Obligatoire pour toutes les entit√©s JPA. Si vous d√©finissez un autre constructeur avec des param√®tres, assurez-vous √©galement de d√©finir un constructeur sans param√®tres.

```java
public Customer() {
    // Constructeur par d√©faut requis par JPA
}

public Customer(String customerLastName, String customerFirstName) {
    this.customerLastName = customerLastName;
    this.customerFirstName = customerFirstName;
}
```

#### 3. Getters et Setters

Les m√©thodes **getter** et **setter** sont essentielles car elles permettent √† JPA de lire et d'√©crire les valeurs des champs de l'entit√©. Ces m√©thodes doivent √™tre pr√©sentes pour chaque attribut que vous souhaitez persister dans la base de donn√©es.

- **Getters** : M√©thodes qui retournent la valeur d'un champ.

- **Setters** : M√©thodes qui permettent de d√©finir la valeur d'un champ.

Exemple de m√©thodes getter et setter pour la classe `Customer` :

```java
public int getCustomerId() {
    return customerId;
}

public void setCustomerId(int customerId) {
    this.customerId = customerId;
}

public String getCustomerLastName() {
    return customerLastName;
}

public void setCustomerLastName(String customerLastName) {
    this.customerLastName = customerLastName;
}

public String getCustomerFirstName() {
    return customerFirstName;
}

public void setCustomerFirstName(String customerFirstName) {
    this.customerFirstName = customerFirstName;
}
```

#### 4. Configuration dans le fichier `pom.xml`

Pour int√©grer JPA dans un projet Spring Boot, vous devez ajouter les bonnes d√©pendances dans votre fichier `pom.xml`. Deux options sont disponibles : utiliser `javax.persistence` (ancienne version de JPA) ou `jakarta.persistence` (la version plus r√©cente et recommand√©e).

##### Option 1 : Utilisation de `javax.persistence`

Cette option utilise les d√©pendances historiques bas√©es sur `javax.persistence` :

```xml
<dependencies>
    <!-- D√©pendance pour JPA avec javax.persistence -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- D√©pendance pour PostgreSQL -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.3.1</version>
    </dependency>
</dependencies>
```

##### Option 2 : Utilisation de `jakarta.persistence`

Cette option est recommand√©e pour les nouveaux projets car elle utilise la derni√®re version de la sp√©cification JPA :

```xml
<dependencies>
    <!-- D√©pendance pour JPA avec jakarta.persistence -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- D√©pendance pour PostgreSQL -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.3.1</version>
    </dependency>
</dependencies>
```

### Conclusion

Pour que JPA fonctionne correctement dans votre projet, assurez-vous que :
- Vos entit√©s ont les bonnes annotations (`@Entity`, `@Id`, etc.).
- Chaque entit√© dispose d'un constructeur par d√©faut.
- Toutes les propri√©t√©s persist√©es ont des m√©thodes getter et setter.
- Le fichier `pom.xml` est correctement configur√© avec les d√©pendances n√©cessaires.

---

Ces pr√©-requis techniques sont indispensables pour garantir une int√©gration r√©ussie de JPA dans votre application Java. Une fois ces exigences remplies, vous pourrez passer √† la configuration de JPA et √† la cr√©ation de vos premi√®res entit√©s dans la section suivante.

[Revenir en haut](#1-introduction-√†-jpa)







---
---
---

# Annexe 2 - R√âSUM√â SUR LES ANNOTATIONS JPA EN D√âTAILS
---

Les annotations JPA sont essentielles pour configurer le mapping entre les classes Java et les tables de base de donn√©es, ainsi que pour d√©finir les comportements sp√©cifiques li√©s √† la persistance des objets. Voici une br√®ve introduction aux annotations JPA que nous allons explorer en d√©tail plus bas :

- **`@Entity`** : Indique que la classe `Customer` est une entit√© JPA.
- **`@Table(name = "customer")`** : Sp√©cifie que cette entit√© est mapp√©e √† la table `customer` dans la base de donn√©es.
- **`@Id`** : Indique que le champ `customerId` est la cl√© primaire de l'entit√©.
- **`@GeneratedValue(strategy = GenerationType.IDENTITY)`** : Sp√©cifie que la valeur de `customerId` est g√©n√©r√©e automatiquement par la base de donn√©es (g√©n√©ralement pour les colonnes auto-incr√©ment√©es).
- **`@Column(name = "customer_last_name")`** : Associe le champ `lastName` √† la colonne `customer_last_name` de la table.

Pour utiliser ces annotations, vous devez importer les packages suivants selon que vous travaillez avec Jakarta Persistence ou la version ant√©rieure de JPA (`javax.persistence`) :

- **Jakarta Persistence** :
  ```java
  import jakarta.persistence.Entity;
  import jakarta.persistence.Table;
  import jakarta.persistence.Id;
  import jakarta.persistence.GeneratedValue;
  import jakarta.persistence.GenerationType;
  import jakarta.persistence.Column;
  ```

- **Ancienne version (javax.persistence)** :
  ```java
  import javax.persistence.Entity;
  import javax.persistence.Table;
  import javax.persistence.Id;
  import javax.persistence.GeneratedValue;
  import javax.persistence.GenerationType;
  import javax.persistence.Column;
  ```

---

# <a name="annotations-principales"></a> 3.2. Annotations Principales

Les annotations JPA sont utilis√©es pour configurer le mapping entre les classes Java et les tables de base de donn√©es, ainsi que pour d√©finir des comportements sp√©cifiques li√©s √† la persistance.

#### Principales annotations JPA et leur usage

1. **`@Entity`** :
   - Utilis√©e pour marquer une classe comme une entit√© persistante.
   - Chaque classe annot√©e avec `@Entity` est mapp√©e √† une table dans la base de donn√©es.
   - Par exemple, une classe `Customer` annot√©e avec `@Entity` est consid√©r√©e comme une table `customer` dans la base de donn√©es.

2. **`@Table`** :
   - Sp√©cifie le nom de la table dans la base de donn√©es √† laquelle l'entit√© est mapp√©e.
   - Utilis√©e lorsque le nom de la classe et celui de la table diff√®rent.
   - Par exemple, `@Table(name = "customer")` indique que l'entit√© `Customer` est mapp√©e √† la table `customer`.

3. **`@Id`** :
   - Indique que le champ est la cl√© primaire de l'entit√©.
   - Chaque entit√© doit avoir un champ annot√© avec `@Id`.

4. **`@GeneratedValue`** :
   - Sp√©cifie la strat√©gie de g√©n√©ration automatique pour la cl√© primaire.
   - Peut √™tre configur√©e avec `strategy = GenerationType.IDENTITY`, `SEQUENCE`, `AUTO`, ou `TABLE`.

5. **`@Column`** :
   - Permet de personnaliser le mapping d'un champ √† une colonne sp√©cifique dans la base de donn√©es.
   - Permet de d√©finir des propri√©t√©s suppl√©mentaires comme `nullable`, `length`, `unique`.


-------
--------
---------

# Annexe 3 - JPQL, l'API Criteria


- L'interaction avec une base de donn√©es est un aspect fondamental de JPA. Elle permet de r√©cup√©rer, modifier et manipuler les donn√©es persist√©es sous forme d'entit√©s. JPA fournit plusieurs moyens de formuler des requ√™tes pour interagir avec les donn√©es : JPQL (Java Persistence Query Language), l'API Criteria, et les requ√™tes SQL natives. Chacune de ces m√©thodes offre des avantages sp√©cifiques en fonction des besoins de votre application.


- JPQL est un langage de requ√™te orient√© objet, similaire √† SQL, mais con√ßu sp√©cifiquement pour JPA. Contrairement √† SQL, qui interagit directement avec les tables de la base de donn√©es, JPQL op√®re sur les entit√©s JPA et leurs relations. Cela permet de formuler des requ√™tes en utilisant les noms de classe et de propri√©t√© des entit√©s, ce qui rend les requ√™tes plus robustes et ind√©pendantes du sch√©ma de la base de donn√©es sous-jacente.

#### Syntaxe de base

La syntaxe de JPQL est similaire √† celle de SQL, avec quelques diff√©rences cl√©s pour refl√©ter le mod√®le orient√© objet :

- **SELECT** : R√©cup√®re les entit√©s ou leurs attributs.
- **FROM** : Sp√©cifie la classe d'entit√©.
- **WHERE** : Ajoute des conditions aux requ√™tes.
- **JOIN** : Permet de joindre des entit√©s associ√©es.
- **ORDER BY** : Trie les r√©sultats.
- **GROUP BY** : Regroupe les r√©sultats.

#### Exemple pratique

Supposons que vous ayez une entit√© `Customer` et vous souhaitez r√©cup√©rer tous les clients dont le nom est "Dupont". Voici comment vous pouvez le faire avec JPQL :

```java
@Entity
@Table(name = "customer")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String lastName;

    private String firstName;

    // Getters et Setters
}
```

Requ√™te JPQL :

```java
String jpql = "SELECT c FROM Customer c WHERE c.lastName = :lastName";
TypedQuery<Customer> query = entityManager.createQuery(jpql, Customer.class);
query.setParameter("lastName", "Dupont");
List<Customer> results = query.getResultList();
```

#### Explications

- **`SELECT c FROM Customer c`** : R√©cup√®re toutes les instances de `Customer` de la base de donn√©es.
- **`:lastName`** : Utilise un param√®tre nomm√© pour rendre la requ√™te dynamique.
- **`TypedQuery<Customer>`** : Sp√©cifie le type de retour pour une meilleure s√©curit√© de type.

#### Joins et Fetching

JPQL supporte √©galement les jointures pour interroger les entit√©s li√©es. Par exemple, si un `Customer` poss√®de plusieurs `Card`s :

```java
String jpql = "SELECT c FROM Customer c JOIN FETCH c.cards WHERE c.lastName = :lastName";
TypedQuery<Customer> query = entityManager.createQuery(jpql, Customer.class);
query.setParameter("lastName", "Dupont");
List<Customer> results = query.getResultList();
```

- **`JOIN FETCH c.cards`** : Effectue une jointure entre `Customer` et `Card`, tout en chargeant imm√©diatement les cartes associ√©es (fetching).

---

##  Criteria API

#### Introduction

L'API Criteria offre une alternative programmatique et type-safe pour formuler des requ√™tes en JPA. Contrairement √† JPQL, qui est une approche bas√©e sur des cha√Ænes de caract√®res, l'API Criteria construit des requ√™tes de mani√®re dynamique en utilisant des objets Java. Cette approche est particuli√®rement utile lorsque les requ√™tes doivent √™tre construites conditionnellement ou sont complexes.

#### Exemple pratique

Supposons que vous souhaitiez cr√©er une requ√™te pour r√©cup√©rer tous les `Customer` dont le nom est "Dupont" en utilisant l'API Criteria :

```java
CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery<Customer> cq = cb.createQuery(Customer.class);
Root<Customer> customer = cq.from(Customer.class);
cq.select(customer).where(cb.equal(customer.get("lastName"), "Dupont"));

TypedQuery<Customer> query = entityManager.createQuery(cq);
List<Customer> results = query.getResultList();
```

#### Explications

- **`CriteriaBuilder`** : Point d'entr√©e pour construire des requ√™tes Criteria.
- **`CriteriaQuery<Customer>`** : Repr√©sente la requ√™te pour r√©cup√©rer des instances de `Customer`.
- **`Root<Customer> customer`** : Repr√©sente la racine (entit√© de base) de la requ√™te.
- **`cb.equal`** : Cr√©e une condition d'√©galit√© sur l'attribut `lastName`.

#### Combinaison de crit√®res

L'API Criteria permet √©galement de combiner plusieurs crit√®res de mani√®re fluide :

```java
cq.select(customer)
  .where(
      cb.and(
          cb.equal(customer.get("lastName"), "Dupont"),
          cb.like(customer.get("firstName"), "J%")
      )
  );
```

- **`cb.and`** : Combine plusieurs conditions avec un ET logique (`AND`).
- **`cb.like`** : Ajoute une condition de type "LIKE" SQL.

#### Avantages de l'API Criteria

- **Type-safe** : Les erreurs de syntaxe sont d√©tect√©es √† la compilation plut√¥t qu'√† l'ex√©cution.
- **Dynamique** : Les requ√™tes peuvent √™tre construites de mani√®re conditionnelle ou en fonction des param√®tres d'entr√©e.

---

## Requ√™tes Native SQL

#### Introduction

Dans certaines situations, JPQL ou l'API Criteria peuvent ne pas √™tre suffisants pour exprimer des requ√™tes complexes ou sp√©cifiques √† une base de donn√©es. Dans ces cas, JPA permet d'ex√©cuter des requ√™tes SQL natives, directement sur la base de donn√©es sous-jacente. Les requ√™tes SQL natives peuvent √™tre n√©cessaires pour des op√©rations de performance critique ou pour tirer parti des fonctionnalit√©s sp√©cifiques √† un SGBD.

#### Exemple pratique

Supposons que vous souhaitiez r√©cup√©rer tous les clients avec une requ√™te SQL native :

```java
String sql = "SELECT * FROM customer WHERE last_name = :lastName";
Query query = entityManager.createNativeQuery(sql, Customer.class);
query.setParameter("lastName", "Dupont");
List<Customer> results = query.getResultList();
```

#### Explications

- **`createNativeQuery(sql, Customer.class)`** : Cr√©e une requ√™te SQL native. Le deuxi√®me param√®tre mappe les r√©sultats √† l'entit√© `Customer`.
- **`Query`** : Utilis√© pour ex√©cuter des requ√™tes SQL natives qui peuvent retourner des entit√©s ou des r√©sultats scalaires.

#### Avantages et inconv√©nients des requ√™tes SQL natives

- **Avantages** :
  - **Performance** : Acc√®s direct aux optimisations sp√©cifiques au SGBD.
  - **Flexibilit√©** : Capacit√© √† utiliser des fonctionnalit√©s avanc√©es du SGBD non support√©es par JPQL.
- **Inconv√©nients** :
  - **Non portable** : Les requ√™tes SQL natives sont li√©es au SGBD sp√©cifique et ne sont pas portables.
  - **Maintenance** : Le code SQL doit √™tre maintenu s√©par√©ment du mod√®le objet.

#### Requ√™tes natives avec r√©sultats scalaires

Les requ√™tes SQL natives peuvent √©galement retourner des r√©sultats scalaires (par exemple, une somme ou un comptage) :

```java
String sql = "SELECT COUNT(*) FROM customer WHERE last_name = :lastName";
Query query = entityManager.createNativeQuery(sql);
query.setParameter("lastName", "Dupont");
Long count = (Long) query.getSingleResult();
```

### Conclusion

En combinant JPQL, l'API Criteria, et les requ√™tes SQL natives, JPA offre une flexibilit√© remarquable pour interroger et interagir avec les donn√©es persist√©es. Chaque m√©thode a ses propres avantages, et le choix entre elles d√©pend des exigences sp√©cifiques de l'application, de la complexit√© des requ√™tes, et des besoins en performance.


------
------
------

# Annexe 4 - Quand Utiliser Repository ou JPQL ?


#### Requ√™tes Repository
Les requ√™tes Repository en Spring Data JPA sont des m√©thodes pr√©-d√©finies et personnalis√©es dans les interfaces de repository. Ces m√©thodes permettent de g√©rer les op√©rations CRUD (Create, Read, Update, Delete) et autres op√©rations courantes sur les entit√©s sans avoir √† √©crire de code SQL ou JPQL. Elles sont souvent g√©n√©r√©es automatiquement par Spring Data JPA en fonction des conventions de nommage des m√©thodes.

**Avantages :**
- **Simplicit√©** : Il suffit de d√©finir des m√©thodes dans l'interface Repository sans √©crire de code SQL ou JPQL.
- **Gain de temps** : Les m√©thodes de base sont d√©j√† int√©gr√©es, comme `findAll`, `save`, `deleteById`, etc.
- **Maintenance facile** : Les m√©thodes sont auto-g√©n√©r√©es et suivent les conventions de Spring, ce qui facilite la maintenance.

**Inconv√©nients :**
- **Limit√© aux requ√™tes simples** : Les m√©thodes g√©n√©r√©es automatiquement sont efficaces pour les requ√™tes simples mais peuvent devenir limit√©es pour des requ√™tes plus complexes.

#### Requ√™tes JPQL (Java Persistence Query Language)
JPQL est une version orient√©e objet de SQL utilis√©e pour interroger les bases de donn√©es relationnelles √† travers des entit√©s JPA. Contrairement aux requ√™tes SQL traditionnelles, JPQL travaille avec les objets Java plut√¥t qu'avec les tables et colonnes de la base de donn√©es.

**Avantages :**
- **Flexibilit√©** : JPQL permet d'√©crire des requ√™tes complexes, y compris des jointures, des agr√©gations, et des sous-requ√™tes.
- **Contr√¥le total** : Vous avez un contr√¥le total sur la fa√ßon dont la requ√™te est ex√©cut√©e, ce qui est utile pour des op√©rations plus complexes.

**Inconv√©nients :**
- **Complexit√©** : N√©cessite une connaissance approfondie de JPQL et de la structure des entit√©s pour √©crire des requ√™tes efficaces.
- **Temps de d√©veloppement** : √âcrire des requ√™tes JPQL complexes peut prendre plus de temps que l'utilisation de m√©thodes Repository standard.

### Tableau Comparatif : Repository vs JPQL

Voici un tableau ASCII comparatif entre les requ√™tes Repository et les requ√™tes JPQL :

```plaintext
+------------------------+---------------------------+-------------------------+
| Crit√®re                | Requ√™tes Repository        | Requ√™tes JPQL            |
+------------------------+---------------------------+-------------------------+
| Facilit√© d'utilisation | Facile, bas√© sur les       | Plus complexe, n√©cessite |
|                        | conventions de Spring     | une bonne connaissance   |
|                        |                            | de JPQL                  |
+------------------------+---------------------------+-------------------------+
| Flexibilit√©            | Limit√©e √† des requ√™tes     | Tr√®s flexible, permet    |
|                        | simples                   | des requ√™tes complexes   |
+------------------------+---------------------------+-------------------------+
| Rapidit√© de mise en    | Rapide, surtout pour les   | Plus lent, car il faut   |
| ≈ìuvre                  | op√©rations CRUD de base    | √©crire manuellement les  |
|                        |                            | requ√™tes                |
+------------------------+---------------------------+-------------------------+
| Maintenance            | Facile √† maintenir gr√¢ce   | Plus difficile √†         |
|                        | aux m√©thodes g√©n√©r√©es      | maintenir, surtout pour  |
|                        | automatiquement           | les requ√™tes complexes   |
+------------------------+---------------------------+-------------------------+
| Performance            | Bon pour les requ√™tes      | Peut √™tre optimis√© pour  |
|                        | simples                   | des sc√©narios complexes  |
+------------------------+---------------------------+-------------------------+
```

### Quand Utiliser Repository ou JPQL ?

- **Utilisez Repository** pour des op√©rations CRUD de base et des requ√™tes simples. C'est rapide, facile √† impl√©menter, et suffisant pour la plupart des cas d'utilisation courants.
  
- **Utilisez JPQL** lorsque vous avez besoin d'√©crire des requ√™tes complexes, comme des jointures multiples, des agr√©gations, ou des sous-requ√™tes. JPQL offre la flexibilit√© n√©cessaire pour les sc√©narios o√π les m√©thodes de Repository g√©n√©r√©es ne suffisent pas.


--------
--------
---------

# Annexe 5 - Validation des Donn√©es



#### Qu'est-ce que la validation des donn√©es (Utilisation de Bean Validation) ?

Imaginez que vous √©crivez une lettre et que vous voulez √™tre s√ªr qu'elle ne contienne pas de fautes d'orthographe avant de l'envoyer. La validation des donn√©es en JPA, c'est un peu la m√™me chose : avant de sauvegarder des informations dans une base de donn√©es, on veut s'assurer qu'elles sont correctes, comme v√©rifier que l'email d'un utilisateur est bien √©crit, ou qu'un √¢ge est bien un nombre positif. 

#### Pourquoi c'est important ?

- **Prot√©ger la base de donn√©es** : En emp√™chant les erreurs de se glisser dans les donn√©es, on √©vite des probl√®mes plus tard.
- **Am√©liorer l'exp√©rience utilisateur** : Si un utilisateur fait une erreur en remplissant un formulaire, on peut lui dire tout de suite ce qui ne va pas, au lieu de l'enregistrer dans la base de donn√©es.

#### Bean Validation : La v√©rification automatique

**Bean Validation** est un ensemble d'outils que Java met √† disposition pour v√©rifier automatiquement si les donn√©es sont correctes. Vous n'avez m√™me pas besoin d'√©crire beaucoup de code pour l'utiliser. Il suffit de mettre quelques annotations (des petits mots-cl√©s) sur les champs que vous voulez v√©rifier.

#### Exemple tr√®s simple

Disons que vous avez une classe qui repr√©sente un client (`Customer`). Vous voulez √™tre s√ªr que le client a un nom, un pr√©nom, et un email valide. Voici comment vous pouvez faire cela avec Bean Validation :

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.validation.constraints.Email; // Pour v√©rifier les emails
import jakarta.validation.constraints.NotNull; // Pour s'assurer qu'un champ n'est pas nul
import jakarta.validation.constraints.Size; // Pour v√©rifier la taille d'un texte

@Entity
@Table(name = "customer")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull(message = "Le nom ne peut pas √™tre nul")
    @Size(min = 2, max = 30, message = "Le nom doit avoir entre 2 et 30 caract√®res")
    private String lastName;

    @NotNull(message = "Le pr√©nom ne peut pas √™tre nul")
    @Size(min = 2, max = 30, message = "Le pr√©nom doit avoir entre 2 et 30 caract√®res")
    private String firstName;

    @Email(message = "L'email doit √™tre valide")
    private String email;

    // Getters et Setters (c'est-√†-dire les m√©thodes pour acc√©der aux donn√©es)
}
```

#### D√©composons cet exemple :

- **`@NotNull`** : Imaginez que vous avez une bo√Æte o√π vous mettez des informations. Cette annotation dit que la bo√Æte ne peut jamais √™tre vide. Par exemple, `lastName` (le nom de famille) ne doit jamais √™tre laiss√© vide. Si vous essayez de cr√©er un `Customer` sans nom, Java dira "Non, c'est pas bon, il manque le nom !".
  
- **`@Size(min = 2, max = 30)`** : Pour les noms et pr√©noms, vous ne voulez pas qu'ils soient trop courts (comme "A") ni trop longs (comme "Supercalifragilisticexpialidocious"). Cette annotation v√©rifie que la taille du texte est entre 2 et 30 caract√®res.

- **`@Email`** : On ne veut pas que quelqu'un entre n'importe quoi comme email, comme "toto@bizarre". Cette annotation v√©rifie que l'email ressemble √† un email, c'est-√†-dire qu'il contient un "@" et un nom de domaine valide.

#### Qu'est-ce qui se passe en cas d'erreur ?

Supposons que vous essayez de cr√©er un `Customer` avec un nom trop court, un pr√©nom manquant, et un email incorrect. Voici ce que vous pouvez faire :

```java
Customer customer = new Customer();
customer.setLastName("A"); // Trop court
customer.setFirstName(null); // Manquant
customer.setEmail("email-pas-valide"); // Format incorrect

try {
    entityManager.persist(customer); // On essaie de sauvegarder
} catch (ConstraintViolationException e) {
    // Oups, quelque chose ne va pas ! On affiche les erreurs
    e.getConstraintViolations().forEach(violation -> {
        System.out.println("Erreur sur " + violation.getPropertyPath() + " : " + violation.getMessage());
    });
}
```

- **`ConstraintViolationException`** : C'est une exception (une erreur) que Java lance quand il y a un probl√®me de validation. Ici, Java vous dira exactement ce qui ne va pas, comme "Le nom est trop court" ou "L'email n'est pas valide".

#### Plus de validations : D'autres choses √† v√©rifier

- **`@Min(value = 18)`** : Parfait pour s'assurer que l'√¢ge d'une personne est au moins 18.
- **`@Max(value = 100)`** : Pour s'assurer que l'√¢ge ne d√©passe pas 100.
- **`@Pattern(regexp = "regex")`** : Imaginez que vous voulez v√©rifier que le num√©ro de t√©l√©phone suit un certain format, par exemple 10 chiffres. Vous pouvez utiliser une expression r√©guli√®re (regex) pour cela.

#### Validation automatique avec JPA

Une fois que vous avez mis en place toutes ces validations, vous n'avez plus √† vous en soucier √† chaque fois que vous enregistrez quelque chose. JPA le fait automatiquement pour vous. Si quelque chose ne va pas, il vous enverra une erreur avant que les donn√©es ne soient enregistr√©es dans la base de donn√©es.

#### Validation dans les formulaires

Si vous utilisez des formulaires pour que les utilisateurs saisissent des donn√©es, vous pouvez aussi valider ces donn√©es avant m√™me qu'elles ne soient envoy√©es au serveur. Par exemple, dans une application web, si quelqu'un entre un email incorrect, vous pouvez lui dire tout de suite avant qu'il n'appuie sur "Envoyer".

Exemple dans un contr√¥leur Spring :

```java
@RestController
public class CustomerController {

    @PostMapping("/customers")
    public ResponseEntity<Customer> createCustomer(@Valid @RequestBody Customer customer) {
        // Si l'objet Customer est invalide, Java renvoie une erreur tout de suite
        return ResponseEntity.ok(customerService.save(customer));
    }
}
```

- **`@Valid`** : Cette petite annotation dit √† Java de v√©rifier que tout est correct dans l'objet `Customer` avant de continuer.

#### Pi√®ges √† √©viter

- **Oublier de valider** : Si vous oubliez d'ajouter `@Valid`, Java n'effectuera pas les v√©rifications, et vous risquez d'enregistrer des donn√©es incorrectes.
- **Ne pas g√©rer les erreurs** : Si vous ne g√©rez pas correctement les erreurs, l'utilisateur pourrait ne pas comprendre pourquoi son formulaire a √©chou√©.

---

### Conclusion

Valider les donn√©es est essentiel pour s'assurer que tout ce que vous enregistrez dans la base de donn√©es est correct. Avec Bean Validation, vous avez un moyen simple de mettre en place ces v√©rifications directement dans vos classes d'entit√©s. En suivant ces √©tapes, vous pouvez garantir que vos donn√©es sont toujours valides, ce qui rendra votre application plus robuste et fiable.

[‚¨ÜÔ∏è Retour en Haut](#jpa)




---------
----------
----------

# Annexe 6 - Relation entre Hibernate et JPA

Je vais t'expliquer la relation entre JPA et Hibernate en utilisant des analogies pour rendre le concept plus clair.

### JPA (Java Persistence API)

**JPA** est une **sp√©cification**. Cela signifie qu'elle d√©finit un ensemble de r√®gles, d'interfaces, et de concepts que les d√©veloppeurs doivent suivre pour g√©rer la persistance des objets Java dans une base de donn√©es relationnelle. Cependant, JPA ne fournit pas de code r√©el ou de framework pour mettre ces r√®gles en pratique. C'est un peu comme une recette de cuisine : elle te dit quels ingr√©dients utiliser et quelles √©tapes suivre, mais elle ne cuisine pas le plat pour toi.

### Hibernate

**Hibernate**, en revanche, est une **impl√©mentation** de JPA. Cela signifie qu'Hibernate prend les concepts et les r√®gles d√©finis par JPA et les impl√©mente sous forme de code concret que tu peux utiliser dans ton application Java. C'est comme si Hibernate √©tait le cuisinier qui utilise la recette (JPA) pour pr√©parer un plat r√©el.

### Comment JPA et Hibernate fonctionnent ensemble

- **JPA** d√©finit **ce que** tu dois faire pour persister des objets Java dans une base de donn√©es. Elle te dit, par exemple, que tu dois annoter tes classes avec `@Entity`, sp√©cifier les relations entre tes objets avec des annotations comme `@OneToMany` ou `@ManyToOne`, etc.

- **Hibernate** est l'un des frameworks qui impl√©mente ces r√®gles d√©finies par JPA. Lorsque tu utilises Hibernate dans ton projet, tu respectes les r√®gles de JPA (par exemple, en utilisant les annotations JPA), et Hibernate fait tout le travail pour convertir ces objets en tables de base de donn√©es, ex√©cuter les requ√™tes SQL, g√©rer les transactions, etc.

### Exemple concret

Imaginons que tu as une classe Java `Customer` que tu veux sauvegarder dans une base de donn√©es :

1. **Avec JPA**, tu utiliseras des annotations pour indiquer que cette classe doit √™tre persist√©e dans la base de donn√©es. Par exemple, tu utiliseras `@Entity` pour indiquer que `Customer` est une entit√© persistante et `@Id` pour sp√©cifier la cl√© primaire.

    ```java
    @Entity
    public class Customer {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String name;
        // Getters et setters...
    }
    ```

2. **Hibernate**, en tant qu'impl√©mentation de JPA, va prendre cette classe annot√©e et faire le n√©cessaire pour cr√©er une table `Customer` dans la base de donn√©es, ins√©rer des lignes lorsque tu ajoutes des objets `Customer`, et les r√©cup√©rer quand tu les demandes. Hibernate s'occupe de tout ce qui se passe sous le capot, comme la g√©n√©ration de la requ√™te SQL `INSERT INTO Customer (name) VALUES (?)`, l'ex√©cution de cette requ√™te, etc.

### Pourquoi utiliser JPA avec Hibernate ?

- **Portabilit√©** : En utilisant JPA, tu rends ton code plus portable. Comme JPA est une sp√©cification standard, tu peux changer d'impl√©mentation (par exemple, passer d'Hibernate √† EclipseLink) sans changer beaucoup de code. C'est un peu comme utiliser une interface en Java : tant que l'impl√©mentation respecte l'interface, tu peux la changer sans impacter le reste de ton application.

- **Fonctionnalit√©s suppl√©mentaires** : Hibernate offre des fonctionnalit√©s qui vont au-del√† de JPA. Par exemple, Hibernate Envers pour l'audit, Hibernate Search pour la recherche en texte int√©gral, etc. Cela te permet de b√©n√©ficier des avantages de JPA tout en ayant acc√®s √† des outils puissants pour des besoins sp√©cifiques.

### Comparaison simple

| Concept        | JPA                                    | Hibernate                               |
| -------------- | -------------------------------------- | --------------------------------------- |
| **Type**       | Sp√©cification (ensemble de r√®gles)     | Impl√©mentation de la sp√©cification JPA  |
| **Responsabilit√©** | D√©finir comment les objets Java doivent √™tre persist√©s | Mettre en ≈ìuvre la persistance des objets en utilisant les r√®gles de JPA |
| **Exemple**    | D√©finir des annotations comme `@Entity`, `@Id` | G√©n√©rer des requ√™tes SQL, g√©rer les transactions, etc. |
| **Portabilit√©** | Tr√®s portable entre diff√©rentes impl√©mentations | Principalement utilis√© comme impl√©mentation de JPA |

### En r√©sum√©

- **JPA** te dit **ce que** tu dois faire pour persister des objets Java dans une base de donn√©es.
- **Hibernate** fait **comment** ce travail est r√©ellement accompli en tant qu'impl√©mentation de JPA, tout en offrant des fonctionnalit√©s suppl√©mentaires.



[‚¨ÜÔ∏è Retour en Haut](#jpa)




---------
----------
----------

# Annexe 7 - Hibernate en d√©tails

Hibernate est l'une des impl√©mentations les plus populaires de la sp√©cification JPA (Java Persistence API). JPA est une norme qui d√©finit comment les donn√©es relationnelles doivent √™tre g√©r√©es dans une application Java, mais elle ne fournit pas d'impl√©mentation concr√®te. Hibernate, en revanche, est un framework ORM (Object-Relational Mapping) qui impl√©mente JPA, permettant ainsi aux d√©veloppeurs d'interagir avec des bases de donn√©es relationnelles en utilisant des objets Java.

### Voici comment Hibernate se positionne par rapport √† JPA :

- **JPA (Java Persistence API)** : C'est une sp√©cification (un ensemble d'interfaces et d'annotations) qui d√©finit comment les objets Java doivent √™tre persist√©s dans une base de donn√©es relationnelle. JPA est une partie de la sp√©cification Java EE, mais il peut √©galement √™tre utilis√© dans des applications Java SE.

- **Hibernate** : C'est une impl√©mentation de JPA, ce qui signifie que Hibernate respecte les r√®gles et les interfaces d√©finies par JPA tout en fournissant des fonctionnalit√©s suppl√©mentaires et des optimisations qui vont au-del√† de la sp√©cification JPA. En d'autres termes, Hibernate vous permet d'utiliser JPA tout en b√©n√©ficiant de ses propres extensions et am√©liorations.

### Voici quelques points cl√©s √† propos de Hibernate et JPA :

1. **JPA est une interface, Hibernate est une impl√©mentation** : JPA ne fournit que les sp√©cifications. Hibernate est un framework qui impl√©mente ces sp√©cifications, ce qui vous permet d'√©crire du code compatible JPA.

2. **Extensions Hibernate** : En plus des fonctionnalit√©s standard JPA, Hibernate offre des extensions comme Hibernate Envers pour l'audit, Hibernate Search pour la recherche en texte int√©gral, et d'autres outils pour simplifier et optimiser la gestion des entit√©s.

3. **Configuration et Utilisation** : Lorsque vous utilisez Hibernate comme impl√©mentation de JPA, vous configurez g√©n√©ralement votre projet pour utiliser les annotations JPA. Vous pouvez √©galement utiliser les annotations sp√©cifiques √† Hibernate pour acc√©der √† des fonctionnalit√©s avanc√©es.

### Exemple de Configuration JPA avec Hibernate dans un projet Spring Boot

#### Ajouter les d√©pendances dans `pom.xml`

**Option 1 : Utilisation de JPA avec Hibernate**

```xml
<dependencies>
    <!-- D√©pendance pour JPA avec Spring Boot -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- D√©pendance pour Hibernate -->
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-core</artifactId>
        <version>5.4.31.Final</version>
    </dependency>

    <!-- D√©pendance pour PostgreSQL -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.3.1</version>
    </dependency>
</dependencies>
```

#### Annotations importantes pour utiliser JPA avec Hibernate

- **@Entity** : Indique que la classe est une entit√© JPA qui sera mapp√©e √† une table de base de donn√©es.
- **@Table** : Utilis√©e pour sp√©cifier le nom de la table en base de donn√©es.
- **@Id** : Indique le champ qui sera utilis√© comme cl√© primaire.
- **@GeneratedValue** : D√©finit la strat√©gie de g√©n√©ration des valeurs pour la cl√© primaire.
- **@ManyToOne, @OneToMany, @ManyToMany** : G√®rent les relations entre les entit√©s.

**Exemple :**

```java
package com.example.demo.model;

import jakarta.persistence.*;

@Entity
@Table(name = "customer")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int customerId;

    @Column(name = "customer_last_name")
    private String customerLastName;

    @Column(name = "customer_first_name")
    private String customerFirstName;

    // Getters et Setters

    public int getCustomerId() {
        return customerId;
    }

    public void setCustomerId(int customerId) {
        this.customerId = customerId;
    }

    public String getCustomerLastName() {
        return customerLastName;
    }

    public void setCustomerLastName(String customerLastName) {
        this.customerLastName = customerLastName;
    }

    public String getCustomerFirstName() {
        return customerFirstName;
    }

    public void setCustomerFirstName(String customerFirstName) {
        this.customerFirstName = customerFirstName;
    }
}
```

### Configuration des Propri√©t√©s dans `application.properties`

```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/your_database
spring.datasource.username=your_username
spring.datasource.password=your_password

spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
```

### Diff√©rences entre Hibernate et JPA :

| Crit√®re                        | JPA                                             | Hibernate                                         |
| ------------------------------ | ----------------------------------------------- | ------------------------------------------------- |
| **Nature**                     | Sp√©cification (API)                             | Framework (impl√©mente JPA)                        |
| **Fonctionnalit√©s suppl√©mentaires** | Limit√© aux sp√©cifications JPA                    | Offre des fonctionnalit√©s suppl√©mentaires comme Envers, Search, etc. |
| **Utilisation**                | Peut √™tre utilis√© avec n'importe quelle impl√©mentation JPA | Utilis√© principalement comme l'impl√©mentation la plus courante de JPA |
| **Configuration**              | Bas√©e sur les annotations JPA standard          | Peut utiliser des annotations JPA ou des annotations sp√©cifiques √† Hibernate |
| **Performances**               | D√©pend de l'impl√©mentation                      | Souvent optimis√© avec des fonctionnalit√©s avanc√©es |

Hibernate est donc √† la fois une impl√©mentation de JPA et un framework riche en fonctionnalit√©s qui vont bien au-del√† des sp√©cifications JPA standard. Il permet de g√©rer la persistance des objets Java avec une grande flexibilit√©, tout en offrant des outils avanc√©s pour l'audit, la recherche, et d'autres besoins sp√©cifiques.


[‚¨ÜÔ∏è Retour en Haut](#jpa)
